{"title":"WeDeploy‚Ñ¢","githubRepo":"wedeploy/wedeploy.com","googleAnalytics":"UA-37033501-3","index":{"children":{"chat":{"title":"Chat","url":"//chat.wedeploy.com/","weight":3,"content":"","srcFilePath":"src/pages/chat.fm","id":"chat"},"get-started":{"title":"Get Started","url":"//dashboard.wedeploy.com/signup","weight":5,"content":"","srcFilePath":"src/pages/get-started.fm","id":"get-started"},"login":{"title":"Log in","url":"//dashboard.wedeploy.com/login","weight":4,"content":"","srcFilePath":"src/pages/login.fm","id":"login"},"blog":{"children":{"3-reasons-why-you-should-use-environment-variables":{"title":"3 Reasons Why You Should Use Environment Variables","description":"There are some really big things coming down the pipe with our Beta release right around the corner, but we just couldn't wait to tell you about something we are really excited about: Environment Variables.","date":"March  29, 2017","author":"Jonni Lundy","image":"http://wedeploy.com/images/blog/post-7--0.gif","layout":"blog","content":" There are some really big things coming down the pipe with our Beta release right around the corner, but we just couldn't wait to tell you about something we are really excited about: Environment Variables. Environments have been around for a while, mainly hiding in the deep code forests, so we wanted to highlight them and share that we wrote some fresh documentation so you can start using them right away! Here are a couple easy ways they can improve your app! ‚Äã üöÄ Change Hosting serve directory By default, WeDeploy Hosting looks to your service's root directory to know what files to serve, but what if you are using a Gulp or Grunt build task to compile your files? No problem, just add the WEDEPLOYWEBPATH key and use the build path as your value. See the full list at our Hosting Environment Variable Docs. üîê Integrate OAuth into your app Want your users to log in with Facebook, Google, or Github accounts? Perfect, because that is super easy to do with WeDeploy Auth. Start by just adding a few environment variables for each provider. See the full list at our Auth Environment Variable Docs. üìß Change Email provider WeDeploy Email supplies you with an email service straight out of the box, but what if you want to use your own SMTP server? With Environment Variables, you can change the email host, username, port, and much more. See the full list at our Email Environment Variable Docs. That's it! If you have any question, just shoot us an email or join the conversation on Slack. Happy coding! üíª ","srcFilePath":"src/pages/blog/3-reasons-why-you-should-use-environment-variables.md","id":"3-reasons-why-you-should-use-environment-variables","url":"/blog/3-reasons-why-you-should-use-environment-variables.html"},"environment-variables-new-java-service-and-multiple-custom-domains":{"title":"Environment variables, new Java service, and multiple custom domains!","description":"We shipped some really interesting features recently and we would love to share them with you!","date":"Oct  31, 2016","author":"Eduardo Lundgren","image":"http://wedeploy.com/images/blog/post-2--2.png","layout":"blog","content":" {$page.description} Environment Variables An important piece of any kind of deployment is setting up environment variables. This can be used to protect credentials for an external database or a secret key that only a production environment should use. Now you can do this by going to the \"Environment\" tab on any WeDeploy service. New Java Service As part of our mission to create a very broad platform for all developers, we're introducing a new Java service. If you're interested, check the boilerplate examples we created using Gradle, Maven, and Ant. As part of our mission to create a very broad platform for all developers, we're introducing a new Java service. Multiple Custom Domains In the past, you could only set one custom domain per project. Although that was useful for many people, there are many cases where you need to configure more than one domain. Now you have the ability to do that by going to the \"Settings\" menu on your project. If you have any questions, feel free to contact us. Happy coding! ","srcFilePath":"src/pages/blog/environment-variables-new-java-service-and-multiple-custom-domains.md","id":"environment-variables-new-java-service-and-multiple-custom-domains","url":"/blog/environment-variables-new-java-service-and-multiple-custom-domains.html"},"happy-new-year-from-wedeploy":{"title":"Happy New Year from WeDeploy","description":"It‚Äôs officially 2017! Are you as excited as we are?","date":"Jan 03, 2017","author":"Zeno Rocha","image":"http://wedeploy.com/images/blog/post-3--0.png","layout":"blog","content":" {$page.description} Last year, on September 20th, the very first app was created on WeDeploy. After that, we went to Chicago, Milan, London, Darmstad, and S√£o Paulo to spread the word about this new product. Today, we're serving hundreds of projects from awesome developers like you. We're proud. We're thankful. We're motivated! So, thank you all for being on this journey with us. We're serving hundreds of projects from awesome developers like you. And you know what, this is just the beginning. We have new and amazing stuff coming soon, including brand new services and tons of scalability improvements for you. Happy New Year! ","srcFilePath":"src/pages/blog/happy-new-year-from-wedeploy.md","id":"happy-new-year-from-wedeploy","url":"/blog/happy-new-year-from-wedeploy.html"},"liferay-hack-day":{"title":"Liferay Hack Day 2017","description":"The holiday season is an exciting time. Not only do we get to put all our diets on hold because of the never ending flow of tree shaped cookies and ooey gooey chocolate fudge, but it also means that the annual Liferay engineering retreat is right around the corner.","date":"Feb 15, 2017","author":"Jonni Lundy","image":"http://wedeploy.com/images/blog/post-5--0.png","layout":"blog","content":" {$page.description} Every January, developers from all around the world gather at our Los Angeles office. It's an exhilarating time together full of talks, catered meals, new friendships, and even spontaneous adventures to the Hollywood sign and the Santa Monica Pier. On the final day of the retreat, we put on a hack day (because how could we bring all the engineers to one location without having one?!). Every year we are amazed at the creativity of the projects, and this year did not disappoint. There are only two requirements for their projects: The code needs to be new It has to be pushed to Github On top of that, this year we encouraged the teams to use WeDeploy to host their projects. Four teams did, and these were there projects. Game Room Availability Nobody wants to walk all the way down to the Game Room to find that the ping pong table is taken. Never fear, Game Room Availability app is here to show you in real time if anyone is using your game. What they used: WeDeploy‚Ñ¢ Hosting. Liferay Home Don't ever come home to a freezing cold house again. Liferay home will learn your habits, track your commute, and automate pretty much anything in your house. What they used: WeDeploy‚Ñ¢ Hosting, WeDeploy‚Ñ¢ Data. Release Notes Annoyed by manually checking for fix pack releases for Portal 7.0? This team created an app that fetched the fix pack information and sorted them by component so you easily find what you need. What they used: WeDeploy‚Ñ¢ Hosting. Chicken Fingers Don't let the name deceive you, this project was the real deal- and the grand prize winner of the hack day. Using voice recognition, they paved the way for a stellar hands-free-recipe cooking experience. What they used: WeDeploy‚Ñ¢ Hosting, WeDeploy‚Ñ¢ Data. We were so impressed with what the teams came up with in less than nine hours! We hope that these projects have inspired you to keep creating, to keep dreaming, and of course, to keep deploying. üöÄ ","srcFilePath":"src/pages/blog/liferay-hack-day.md","id":"liferay-hack-day","url":"/blog/liferay-hack-day.html"},"my-first-three-months-with-wedeploy":{"title":"My First Three Months With WeDeploy","description":"Hey! My name is Jonni and I'm a UI intern on the WeDeploy team. I joined back in November and wanted to share a couple things from my first three months at Liferay.","date":"Jan 13, 2017","author":"Jonni Lundy","image":"http://wedeploy.com/images/blog/post-4--0.png","layout":"blog","content":" {$page.description} I have no coding background. Before my internship, I had never opened DevTools in my life and I thought that Java and JavaScript were the same thing. Needless to say, I was a little intimidated of coming in as the new guy, but once I started using WeDeploy and working with the team, those fears drifted away like a bunch of balloons strapped to a house ('UP' anyone?). I still remember the first time I deployed. I had just finished making my very first website, and Zeno said I should try deploying it by myself. I honestly didn't know where to start, so I went to the docs, read through some guides, and gave it a shot. Within 15 minutes, it was live! It was one of the best feelings I've had during this internship. Knowing that I, the new guy who didn't know what an API was or how to run 'npm install', could deploy my own website faster than it takes me to run to Starbucks and get my triple ristretto hazelnut latte (with almond milk please). By far my favorite thing about being on the WeDeploy team is being able to get behind a product that is so powerful and yet incredibly intuitive to use. If I can deploy, then I'm sure you can! So what are you waiting for?! ","srcFilePath":"src/pages/blog/my-first-three-months-with-wedeploy.md","id":"my-first-three-months-with-wedeploy","url":"/blog/my-first-three-months-with-wedeploy.html"},"starting-an-iot-platform-with-wedeploy":{"title":"Starting an IoT platform with WeDeploy","description":"In this blog post I will guide you through the steps to create a minimal IoT platform which accepts metrics from remote devices. To build this multi-service project, I will use the WeDeploy Java, Hosting, and Data services.","date":"Mar 17, 2017","author":"Manuel de la Pe√±a","image":"/images/blog/post-6--0.png","layout":"blog","content":" {$page.description} I'm currently studying Research in Software Engineering and Computer Science for my master's degree and decided to build this platform to complete some requirements for a class about Ubiquitous Computing. In this class I've learned the basic concepts of IoT, starting with the initial intent to simulate the real world with smart devices. I believe the IoT train is passing and if we don't get on, we will miss out. That's why I decided to explore more. I realized that in the short period of time I had to accomplish this, I would need to learn how to use and configure a complete new tool like Kaa or Machina.io. But I just wanted a place to simulate an IoT platform super fast. Then a thought occured to me: Why not use WeDeploy to host my app? It already provides all the infrastructure I need. With WeDeploy, you manage git repositories and wrap them into services that can be deployed into the platform. It also offers a set of useful, already-configured services such as Data, Users and Auth, or even a E-mail. This allows any developer to streamline a project with minimal infrastructure configuration so they can just focus on coding the application they want to develop. The Stack So, here are the requirements for my project: An Android app that reads current speeds from a GPS and sends it each time the current location is changed. A server that reads the metrics sent by the Android app and stores them into persistent storage. A web interface to display the metrics stored in the database, reading from the server. The Android app is super easy to create, and has nothing to do with WeDeploy, just knowing the URL of the server where to send the metrics, so I won't go anymore into it. The two things that really matter are related to the API I wanted to create to accept the metrics sent by the devices and the visualisation of those metrics. Creating an API with WeDeploy In order to accept metrics from remote applications, I decided to create a REST API to handle the requests, and then it would store the metrics in a persistent storage. As WeDeploy offers a Data service, I decided that my REST API should communicate to that service to store the metrics. Then, I chose the framework to create the API. As I'm a Java developer, I chose Spring Boot to build it, which lets you create tiny applications and define REST resources in an extremely easy manner. So I created a project on the WeDeploy dashboard, and added a WeDeploy Java service named \"api\". I locally cloned the boilerplate-java project from Github, and started coding my REST API's there. Of course you can do this step with other technology you are more familiar with, and WeDeploy offers several server-side technologies to accomplish this including NodeJS and Ruby. Implementing a service In order to implement a WeDeploy service, it's mandatory to create a container.json file in the root of your folder, where you specify the type of the service you would like to use and some other behaviors. In the case of the WeDeploy Java service, you can set hooks to build the project once the service is created or updated. { \"id\": \"api\", \"type\": \"wedeploy/java:latest\", \"hooks\": { \"build\": \"gradle -Dorg.gradle.native=false clean build -x test\" } } In this case, because I used a Spring Boot project, the build system is based on Gradle, so I added the commands to build the project, excluding tests. Defining REST resources The following block of code demonstrates how to handle HTTP GET and POST requests in a Spring Boot controller. /** We'll handle all HTTP request to the path '/sensors' under application context path @author Manuel de la Pe√±a */ @RestController @RequestMapping(\"/sensors\") public class SensorsRestController { /* Defines the resource for an specific sensor, identified by its sensorId, which is passed as input parameter to the method, using the annotation @PathVariable. It allows CORS requests from any domain. @return A collection of model domain objects */ @CrossOrigin(origins = \"*\") @RequestMapping(method = RequestMethod.GET, value = \"/{sensorId}\") public Collection getMetrics(@PathVariable String sensorId) {...} ... /* Define the resource for POST verb operations over this controller's path. The annotation @RequestBody indicates the type of the object that will be processed in the request. It allows CORS requests from any domain. */ @CrossOrigin(origins = \"*\") @RequestMapping(method = RequestMethod.POST) public ResponseEntity addMetric(@RequestBody Metric metric) {...} ... } Defining the save service Our API service needs to store the metrics in the WeDeploy Data service so I added a new service to the project on the WeDeploy dashboard, naming it data. Again, I cloned the boilerplate-data Github repository at the same level of my API service, and voil√†! I have two services under my WeDeploy project. Here it is the container.json file for this new data service: { \"id\": \"data\", \"type\": \"wedeploy/data\" } But this data service must be configured to create a collection of elements. These are the pieces of data I wanted to gather about the sensor: Platform (app-android, app-ios, app-console), Unique identifier Coordinates (longitude, latitude) Value Name (temperature, speed, pressure, etc.) Unit of measure (celsius degrees, kilometers per hour, atmospheres, etc.) Timestamp (the moment of request) And I also had to define how this collection of data is accessed, and which HTTP verbs are allowed. You can configure this in WeDeploy data service with the api.json descriptor. This block shows the three REST resources that are accepted by my data service, and their specific paths: two for retrieving data, and one for storing data. [ { \"description\": \"Returns all sensors that sent metrics to the platform\", \"path\": \"/sensors/*\", \"method\": \"GET\", \"data\": true }, { \"description\": \"Returns one sensor identified by its unique sensorId\", \"path\": \"/sensors/:sensorId\", \"method\": \"GET\", \"data\": true }, { \"description\": \"Stores one sensor's metrics\", \"path\": \"/sensors\", \"method\": \"POST\", \"data\": true, \"parameters\": { \"applicationId\": { \"type\": \"string\" }, \"sensorId\": { \"type\": \"string\" }, \"latitude\": { \"type\": \"string\" }, \"longitude\": { \"type\": \"string\" }, \"metric\": { \"type\": \"string\" }, \"metricName\": { \"type\": \"string\" }, \"metricUnits\": { \"type\": \"string\" }, \"timestamp\": { \"type\": \"string\" } } } ] As you can see for the POST operation, I can validate the input parameters that are sent to the WeDeploy data service. Storing in the WeDeploy Data service Ok, once I had the data service configured, how could I communicate with it from the Java service, which represents the API? Well, the smart guys from WeDeploy team have provided a set of libraries to communicate with any WeDeploy service in an easy manner: you can consume WeDeploy's APIs with language-specific clients. In my case I will use a Java client, which I added to Gradle dependencies in the Java service. dependencies { compile(\"com.github.wedeploy.api-java:api:master-SNAPSHOT\") compile(\"com.github.wedeploy.api-java:api-client:master-SNAPSHOT\") ... } Added the dependencies, the communication with the WeDeploy Data service is performed in this block of code: public class DataRepository { /** Name of the data service to communicate with */ private static final String DATASERVICEPATH = \"data\"; /** Path of the Sensors collection */ private static final String SENSORSDATAPATH = \"/sensors\"; ... /** We filter the collection by sensorId column. Then, we parse the JSON object that represents the body of the response into a collection of model entities. */ public Collection findBySensorId(String sensorId) { WeDeploy weDeploy = new WeDeploy(DATASERVICEPATH + SENSORSDATAPATH); Response response = weDeploy.filter(\"sensorId\", sensorId).get(); JoddJsonParser parser = new JoddJsonParser(); return parser.parseAsList(response.body(), SensorRow.class); } /** We retrieve the whole collection, without pagination. Then, we parse the JSON object that represents the body of the response into a collection of model entities. */ public Collection findAllSensors() { WeDeploy weDeploy = new WeDeploy(DATASERVICEPATH + SENSORSDATAPATH); Response response = weDeploy.get(); JoddJsonParser parser = new JoddJsonParser(); return parser.parseAsList(response.body(), SensorRow.class); } ... } Here the WeDeploy object hides the magic of communicating with other WeDeploy services. As I'm in the same project, it's possible to resolve the service name directly with only its name, without using its whole URL, because WeDeploy directly resolves service names when services run within the same project. Displaying data At that point I had built two services: a Java REST API developed with Spring Boot, and a WeDeploy Data service for persistence. Then I wanted to display the metrics in a web interface. So, I created a third WeDeploy service, Hosting, which allows uploading static files, such as HTML, CSS and JavaScript, and gave it the name ui. Bellow is the container.json file that I made to impliment the Hosting Service. { \"id\": \"ui\", \"type\": \"wedeploy/hosting\" } I know that this is not related to WeDeploy, but I wanted to display the metrics in two different ways: a datagrid with all metrics, and a Google Maps interface with a pin where a metric was sent. With the following code, which is not the WeDeploy JavaScript client, I can retrieve the JSON objects returned from the Spring Boot API with browser's native fetch capability, process the response, and draw the results in the screen. function getSensors(mode) { return fetch(myUrl) .then(function(response) { if(response.ok) { return response.json(); } else if (response.status !== 200) { return []; } }) .then(function(sensors) { if (!sensors || sensors.length === 0) { noResults(); // shows a not found message return; } if (mode == 'grid') { plotSensors(sensors); // draws a grid } else { mapSensors(sensors); // draws a google map } return this; }); } Please remember I'm a backend developer interested in Systems, so shame on me for this JavaScript code! Hey, at least I put it in a separate JavaScript file. üòÇ Thanks to the WeDeploy team, a JS client is also available. Super cool! You only need to add this script to your page and you're ready to go: Summary With WeDeploy I could accomplish the task of creating a very basic stack to handle requests. I wrote a a service representing an API for accepting requests, a service to store data, and a service representing a UI for the metrics. And all of that has been accomplish just using a couple lines of code + git skills, with no infrastructure knowledge needed! If you're curious about the end result, see: ui.mdelapenya-sensors.wedeploy.io api.mdelapenya-sensors.wedeploy.io ","srcFilePath":"src/pages/blog/starting-an-iot-platform-with-wedeploy.md","id":"starting-an-iot-platform-with-wedeploy","url":"/blog/starting-an-iot-platform-with-wedeploy.html"},"uptime-status-new-ruby-service-and-more":{"title":"Uptime status, new Ruby service, and more!","description":"First of all, we would like to say thanks for trying WeDeploy! You're shaping the future of this product, so we appreciate you taking the time to provide some feedback.","date":"Oct 10, 2016","author":"Zeno Rocha","image":"http://wedeploy.com/images/blog/post-1--0.png","layout":"blog","content":" {$page.description} You're shaping the future of this product. In the last few weeks we've been working day and night to make WeDeploy more stable. Almost two hundred projects have been created since we first launched and dozens of bugs have been fixed. Today, we would like to show you some of the things we're working on. Uptime Status Even though this is an alpha version and problems are somewhat expected, we recognize the importance of being transparent about outages. That's why we would like to share with you a new page where you can check WeDeploy's uptime status. Ruby Service Our mission is to create a platform for all kinds of developers. With that in mind, we're introducing a new Ruby service. You can get more information by reading the docs or checking this boilerplate. Go to Dashboard to start using Ruby Service. Our mission is to create a platform for all kinds of developers. If you have any questions, feel free to contact us. ","srcFilePath":"src/pages/blog/uptime-status-new-ruby-service-and-more.md","id":"uptime-status-new-ruby-service-and-more","url":"/blog/uptime-status-new-ruby-service-and-more.html"}},"title":"Blog","description":"Discover all the latest about WeDeploy.","type":"blog","weight":1,"content":" ","srcFilePath":"src/pages/blog/index.soy","id":"blog","url":"/blog","childIds":["3-reasons-why-you-should-use-environment-variables","starting-an-iot-platform-with-wedeploy","liferay-hack-day","my-first-three-months-with-wedeploy","happy-new-year-from-wedeploy","environment-variables-new-java-service-and-multiple-custom-domains","uptime-status-new-ruby-service-and-more"],"redirect":"/blog/3-reasons-why-you-should-use-environment-variables.html"},"docs":{"title":"Documentation","description":"Everything you need to know to get started.","weight":2,"content":" WeDeploy Docs Center Start learning how to leverage the power of in your project. Choose a Guide Each one provide step by step coverage for every core feature. ","srcFilePath":"src/pages/docs/index.soy","id":"docs","url":"/docs","children":{"auth":{"children":{"environment-variables":{"title":"Environment Variables","description":"Use environment variables to control your app.","headerTitle":"Auth","layout":"guide","weight":7,"content":" {$page.title} {$page.description} Note: If you are unfamiliar with how you can apply and manage your secret keys, please visit our Environment Variables page. Reference Here is a list of all the environment variable keys you can use with this service. | Key | Description | | - | - | | WEDEPLOYAUTHEMAIL_CONTENT | HTML code for password reset email | | WEDEPLOYAUTHEMAIL_SENDER | Set password reset email sender | | WEDEPLOYAUTHEMAIL_SUBJECT | Set password reset email subject | | WEDEPLOYAUTHFACEBOOK | Enable Facebook Auth integration | | WEDEPLOYAUTHFACEBOOKCLIENTID | Facebook OAuth ID | | WEDEPLOYAUTHFACEBOOKCLIENTSECRET | Facebook OAuth password | | WEDEPLOYAUTHGITHUB | Enable GitHub Auth integration | | WEDEPLOYAUTHGITHUBCLIENTID | GitHub OAuth ID | | WEDEPLOYAUTHGITHUBCLIENTSECRET | GitHub OAuth password | | WEDEPLOYAUTHGOOGLE | Enable Google Auth integration | | WEDEPLOYAUTHGOOGLECLIENTID | Google OAuth ID | | WEDEPLOYAUTHGOOGLECLIENTSECRET | Google OAuth password | | WEDEPLOYAUTHPASSWORD | Enable email and password Auth | | WEDEPLOYAUTHSECURE_FIELDS | Select which Auth fields are secured | Check the boilerplate-auth for a practical example. ","srcFilePath":"src/pages/docs/auth/environment-variables.md","id":"environment-variables","url":"/docs/auth/environment-variables.html"},"getting-started":{"title":"Getting Started","description":"Allow users to authenticate using passwords, popular federated identity providers like Google, Facebook, GitHub, and more using WeDeploy‚Ñ¢ Auth","headerTitle":"Auth","layout":"guide","weight":1,"content":" Auth {$page.description} See Live Demo or read the source code. Install dependencies This section assumes that you already have the WeDeploy CLI installed and Docker running. Make sure to visit the installation guide if you need help setting that up. We also feature code snippets using the API Client, visit this guide in order to start using it. Running locally Start local infrastructure: we run Clone this repository: git clone -b js https://github.com/wedeploy/boilerplate-auth.git boilerplate-auth-js cd boilerplate-auth-js Link this container with the local infrastructure: we link Now your container is ready to be used: http://authdemo.wedeploy.me Deploying to the cloud Fork this repository. Go to the Dashboard and create a project. In the sidebar, click on Deployment. Using your local machine, clone your Github fork: git clone -b js https://github.com//boilerplate-auth Get into the folder: cd boilerplate-auth. Using the content on Deployment page. Add the WeDeploy remote url: git remote add wedeploy http://git.wedeploy.com/.git Push your data to wedeploy git server: git push wedeploy js:master. Once you see it in the Dashboard, your container will be ready to be used. http://boilerplate-auth.wedeploy.io Key capabilities Easily add a complete sign-in system to your application. WeDeploy provides a ready-to-use auth solution that handles the UI flows for signing in users with email addresses and passwords, Google Sign-In, GitHub and Facebook Login. Email and password Authenticate users with their email addresses and passwords. Provides methods to create and manage users that use their email addresses and passwords to sign in, and sending password reset emails. Google Create a client id and client secret by registering your application on Google. GitHub Create a client id and client secret by registering your application on GitHub. Facebook Create an app ID by registering your application on Facebook. Manage Users Create, delete or update users with a simple API. Initializing auth service By using WeDeploy API client you can initialize the authentication service by referencing its URL, like in the example below. WeDeploy.auth('http://..wedeploy.me'); WeDeploy.auth('http://..wedeploy.me'); After initializing the authentication service URL, WeDeploy client stores its information for future calls. Note that if you are initializing an auth service pointing to the Cloud you should use the proper domain: WeDeploy.auth('http://..wedeploy.io'); WeDeploy.auth('http://..wedeploy.io'); What's next? Now we're ready to start managing your users. ","srcFilePath":"src/pages/docs/auth/getting-started.md","id":"getting-started","url":"/docs/auth/getting-started.html"},"manage-users":{"title":"Manage Users","description":"Create, delete or update users by using WeDeploy‚Ñ¢ Auth.","headerTitle":"Auth","layout":"guide","weight":2,"content":" {$page.title} {$page.description} Create user You create a new user in your WeDeploy project by calling the createUser method or by signing in a user for the first time using a federated identity provider, such as Google Sign-In or Facebook Login. WeDeploy .auth() .createUser({ email: 'user@domain.com', password: 'abc' }) .then(function(user) { // Successfully created. }) .catch(function(err) { // Not created. }); WeDeploy .auth(\"\") .createUser(email: \"user@domain.com\", password: \"abc\", name: \"somename\") .then { user in // Successfully created. } .catch { err in // Not created. } Get current user var currentUser = WeDeploy.auth().currentUser; if (currentUser) { // User is signed in. } else { // No user is signed in. } WeDeploy .auth(\"\") .getCurrentUser() .then { user in // User found. } .catch { error in // User does not exist. } Get user WeDeploy .auth() .getUser(userId) .then(function(user) { // User found. }) .catch(function(err) { // User does not exist. }); WeDeploy .auth(\"\") .getUser(id: \"userId\") .then { user in // User found. } .catch { error in // User does not exist. } Delete user You can delete a user account with the delete method. For example: var currentUser = WeDeploy.auth().currentUser; currentUser .deleteUser() .then(function() { // Successfully deleted. }) .catch(function(err) { // Not deleted. }); WeDeploy .auth(\"\") .deleteUser(id: \"userId\") .then { _ in // Successfully deleted } .catch { err in // Not deleted. } Update user You can update a user's basic information. For example: var currentUser = WeDeploy.auth().currentUser; currentUser .updateUser({ password: \"password\", email: \"eleven@hawkinslabs.com\", name: \"Eleven\", photoUrl: \"https://hawkinslabs.com/011/profile.jpg\" }) .then(function() { // Successfully updated. }) .catch(function(err) { // Not updated. }); WeDeploy .auth(\"\") .updateUser(id: \"userId\" , email: \"eleven@hawkinslabs.com\", password: \"password\", name: \"Eleven\") .then { _ in // Successfully updated } .catch { err in // Not updated. } Send a password reset email You can send a password reset email to a user with the sendPasswordResetEmail method. For example: WeDeploy .auth() .sendPasswordResetEmail(\"user@domain.com\") .then(function() { // Email sent. }) .catch(function(err) { // An error happened. }); WeDeploy .auth(\"\") .sendPasswordReset(email: \"user@domain.com\") .then { _ in // Successfully signed out. } .catch { err in // Not signed out. } Sign-out WeDeploy .auth() .signOut() .then(function() { // User is signed out. }) .catch(function(err) { // User was signed out. }); WeDeploy .auth(\"\") .signOut() .then { _ in // Successfully signed out. } .catch { err in // Not signed out. } What's next? Now we're ready to start authenticating accounts and growing our user base. ","srcFilePath":"src/pages/docs/auth/manage-users.md","id":"manage-users","url":"/docs/auth/manage-users.html"},"sign-in-with-facebook":{"title":"Sign-in With Facebook","description":"You can let your users authenticate using their Facebook Accounts by integrating Facebook Sign-In into your app.","headerTitle":"Auth","layout":"guide","weight":3,"content":" {$page.title} {$page.description} Sign-in with facebook To sign in by redirecting to the sign-in page, call signInWithRedirect: var auth = WeDeploy.auth(); var provider = new auth.provider.Facebook(); provider.setProviderScope(\"email\"); auth.signInWithRedirect(provider); auth.onSignIn(function(user) { // Fires when user is signed in after redirect. }); let auth = WeDeploy.auth(\"\"); let provider = AuthProvider(provider: .facebook, redirectUri: \"my-app://\") provider.providerScope = \"email\" auth.signInWithRedirect(provider: provider) { (user, error) in // Fires when user is signed in after redirect. } //Add WeDeploy.auth(\"\").handle(url: url) in AppDelegate's open url method Setup app client id and secret Create a client id and client secret by registering your application on Facebook. Please be sure to add the callback url http://..wedeploy.io/oauth/token in your application. For local development, use wedeploy.me instead. To use with custom domains you can change the sufix .wedeploy.io for your domain. After retrieving the client id and client secret you can configure them as environment variables of the authentication container.json. { \"id\": \"auth\", \"name\": \"Auth\", \"type\": \"wedeploy/auth\", \"env\": { \"WEDEPLOYAUTHFACEBOOK\": \"true\", \"WEDEPLOYAUTHFACEBOOKCLIENTID\": \"\", \"WEDEPLOYAUTHFACEBOOKCLIENTSECRET\": \"\" } } Or you can add those environment variables using the dashboard. What's next? Now we're ready to start enabling other login providers into your app. ","srcFilePath":"src/pages/docs/auth/sign-in-with-facebook.md","id":"sign-in-with-facebook","url":"/docs/auth/sign-in-with-facebook.html"},"sign-in-with-github":{"title":"Sign-in With GitHub","description":"You can let your users authenticate using their GitHub Accounts by integrating GitHub Sign-In into your app.","headerTitle":"Auth","layout":"guide","weight":4,"content":" {$page.title} {$page.description} Sign-in with gitHub To sign in by redirecting to the sign-in page, call signInWithRedirect: var auth = WeDeploy.auth(); var provider = new auth.provider.Github(); provider.setProviderScope(\"user:email\"); auth.signInWithRedirect(provider); auth.onSignIn(function(user) { // Fires when user is signed in after redirect. }); let auth = WeDeploy.auth(\"\"); let provider = AuthProvider(provider: .github, redirectUri: \"my-app://\") provider.providerScope = \"user:email\" auth.signInWithRedirect(provider: provider) { (user, error) in // Fires when user is signed in after redirect. } //Add WeDeploy.auth(\"\").handle(url: url) in AppDelegate's open url method Setup app client id and secret Create a client id and client secret by registering your application on GitHub. Please be sure to add the callback url http://..wedeploy.io/oauth/token in your application. For local development, use wedeploy.me instead. To use with custom domains you can change the sufix .wedeploy.io for your domain. After retrieving the client id and client secret you can configure them as environment variables of the authentication container.json. { \"id\": \"auth\", \"name\": \"Auth\", \"type\": \"wedeploy/auth\", \"env\": { \"WEDEPLOYAUTHGITHUB\": \"true\", \"WEDEPLOYAUTHGITHUBCLIENTID\": \"\", \"WEDEPLOYAUTHGITHUBCLIENTSECRET\": \"\" } } Or you can add those environment variables using the dashboard. What's next? Now we're ready to start enabling other login providers into your app. ","srcFilePath":"src/pages/docs/auth/sign-in-with-github.md","id":"sign-in-with-github","url":"/docs/auth/sign-in-with-github.html"},"sign-in-with-google":{"title":"Sign-in With Google","description":"You can let your users authenticate using their Google Accounts by integrating Google Sign-In into your app.","headerTitle":"Auth","layout":"guide","weight":5,"content":" {$page.title} {$page.description} Sign-in with google To sign in by redirecting to the sign-in page, call signInWithRedirect: var auth = WeDeploy.auth(); var provider = new auth.provider.Google(); provider.setProviderScope(\"email\"); auth.signInWithRedirect(provider); auth.onSignIn(function(user) { // Fires when user is signed in after redirect. }); let auth = WeDeploy.auth(\"\"); let provider = AuthProvider(provider: .google, redirectUri: \"my-app://\") provider.providerScope = \"email\" auth.signInWithRedirect(provider: provider) { (user, error) in // Fires when user is signed in after redirect. } //Add WeDeploy.auth(\"\").handle(url: url) in AppDelegate's open url method Setup app client id and secret Create a client id and client secret by registering your application on Google. Please be sure to add the callback url http://..wedeploy.io/oauth/token in your application. For local development, use wedeploy.me instead. To use with custom domains you can change the sufix .wedeploy.io for your domain. After retrieving the client id and client secret you can configure them as environment variables of the authentication container.json. { \"id\": \"auth\", \"name\": \"Auth\", \"type\": \"wedeploy/auth\", \"env\": { \"WEDEPLOYAUTHGOOGLE\": \"true\", \"WEDEPLOYAUTHGOOGLECLIENTID\": \"\", \"WEDEPLOYAUTHGOOGLECLIENTSECRET\": \"\" } } Or you can add those environment variables using the dashboard. What's next? Learn how to sign-up users using their email and password into your app. ","srcFilePath":"src/pages/docs/auth/sign-in-with-google.md","id":"sign-in-with-google","url":"/docs/auth/sign-in-with-google.html"},"sign-in-with-password":{"title":"Sign-in With Password","description":"You can let your users authenticate with WeDeploy using their email addresses and passwords.","headerTitle":"Auth","layout":"guide","weight":6,"content":" {$page.title} {$page.description} Sign-in with password To sign in by email and password, call signInWithEmailAndPassword: WeDeploy .auth() .signInWithEmailAndPassword(\"user@domain.com\", \"password\") .then(function(user) { // User is signed in. }) .catch(function(err) { // User is not signed in. }); WeDeploy .auth(\"\") .signInWith(username: \"user@domain.com\", password: \"password\") .then { auth in // User is signed in. } .catch { err in // User is not signed in. } What's next? Now you can start building your apps with authentication. ","srcFilePath":"src/pages/docs/auth/sign-in-with-password.md","id":"sign-in-with-password","url":"/docs/auth/sign-in-with-password.html"}},"title":"Auth","url":"/docs/auth/getting-started.html","icon":"persons","weight":2,"content":" ","srcFilePath":"src/pages/docs/auth/index.soy","id":"auth","location":"/docs/auth","childIds":["getting-started","manage-users","sign-in-with-facebook","sign-in-with-github","sign-in-with-google","sign-in-with-password","environment-variables"]},"data":{"children":{"configuring-data":{"title":"Configuring Data","description":"The api.json and api-*.json files allow us to configure the accessible paths for each data service.","headerTitle":"Data","layout":"guide","weight":2,"content":" {$page.title} {$page.description} Understanding configuration files By default WeDeploy Data service is going to use all the JSON files starting with api-* and also the file api.json. These files are used to help you manage features such as path validation, authentication, and params validation. The api JSON files are located at the same path of the ./container.json and are used following the ordering filesystem. JSON attributes After understanding how the api configuration files work, it's time to learn what are the supported attributes: | Field | Description | | - | - | | path | The path that represents the collection used to handle the request data. | | data | Tells the service if the request to a collection should be stored or not. | | description | Used to describe the behavior of an endpoint. | | auth | Used to define authentication rules for the endpoint. | | method | HTTP method allowed for the request. | | parameters | Parameters and validation rules for the collection. | path A path represents the resource used to store your project data. [ { \"path\": \"/movies/:movieId\" }, { \"path\": \"/fruits/*\" } ] data You can create endpoints just for validation, in this case, data is used to finish the request in case you just need a validation or want to store the request in the collection. [ { \"path\": \"/fruits/*\", \"data\": true } ] description Used to describe the behavior of an endpoint. [ { \"description\": \"Returns actors of a movie\", \"path\": \"/movies/:movieId/actors\", \"method\": \"GET\" } ] auth You can unauthorized applications and users to access any endpoint by using the auth field. The example below verify if the application is authenticated in order to perform the request: [ { \"path\": \"/movies/*\", \"auth\": { \"validator\": \"$auth != null\" } } ] method Specifies the HTTP method used for the request. In the example bellow, it allows a GET request and if you try to do a PUT or DELETE the route will not be recognized and will fail. [ { \"path\": \"/movies/:movieId\", \"data\": true, \"method\": \"GET\" } ] parameters You generally would use parameters to force validation in order to make sure that the params sent to a collection follow predefined rules. [ { \"description\": \"Creates a new movie\", \"path\": \"/movies\", \"method\": \"POST\", \"parameters\": { \"title\": { \"type\": \"string\" } }, \"data\": true } ] Allowing usage of all the collections In order to freely use any collection with any kind of operation, you just need to add the following content in your api.json. [ { \"path\": \"/*\", \"data\": true } ] The path /\\* tells the data service to allow any request to the base path of the data service. Validating resources The Validator script will be executed in an environment where several request and server data will be available. In this environment, there are several global variables available to you that can be used to validate the request parameter, body, or even to authorize the request. The validator can be used as an integration with the Auth service: { \"path\": \"/movies/*\", \"auth\": { \"validator\": \"$auth != null\" } } The global variables are: | Variable | Description | | - | - | | $auth | The authenticated user of this request. If the request was not authenticated, it will be null. | | $config | The raw JSON data stored in the service's config.json file. | | $session | All stored session data. If the request had no session cookie, it will be an empty map for the new session created for this request. | | $params | The request params as they were loaded from url query and request body. All query and form parameters will be strings here. | | $values | The parsed request params, as they are used for parameter validation. All query and form parameters will be parsed to JSON values. | | $body | The parsed request body, according to the request Content-Type. | | $data | The data view for this request, if a data path is mounted in the API path, and the request path represents a key to access any data resource (collection, document or inner field from a document). It will be null otherwise. | Some common validators are: Authenticated users only: $auth !== null Mixed with dynamic values: $auth.id === $params.id Validate new data value agains old one: $body.timestamp $data.timestamp Multiple contitional validation: $auth !== null && $auth.id === $params.id What's next? Now that you have WeDeploy Data API settled up, you can interact saving data. ","srcFilePath":"src/pages/docs/data/configuring-data.md","id":"configuring-data","url":"/docs/data/configuring-data.html"},"deleting-data":{"title":"Deleting Data","description":"The delete() function destroys an existing field, document or collection in the database.","headerTitle":"Data","layout":"guide","weight":5,"content":" {$page.title} {$page.description} Deleting existing data By default, all the operation access to your database are restricted so only authenticated users can manipulate data. To get started without setting up Authentication, you can configure your rules for public access. To learn more about rules, see configuring rules section. To delete a field, document, or the entire collection, we use the DELETE method: var data = WeDeploy.data('http://datademo.wedeploy.io'); data.delete('movies/starwarsv/title'); data.delete('movies/starwarsv'); data.delete('movies'); let data = WeDeploy.data(\"http://datademo.wedeploy.io\"); data.delete(collectionOrResourcePath: \"movies/starwarsv/title\"); data.delete(collectionOrResourcePath: \"movies/starwarsv\"); data.delete(collectionOrResourcePath: \"movies\"); What's next? Now that you have learned how to update data, you can interact retrieving data. ","srcFilePath":"src/pages/docs/data/deleting-data.md","id":"deleting-data","url":"/docs/data/deleting-data.html"},"getting-started":{"title":"Getting Started","description":"Leverage a NoSQL database with search and real-time capabilities using WeDeploy‚Ñ¢ Data.","headerTitle":"Data","layout":"guide","weight":1,"content":" Data {$page.description} See Live Demo or read the source code. Install dependencies This section assumes you already have the WeDeploy CLI installed and Docker running. Make sure to visit the installation guide if you need help setting that up. We also feature code snippets using the API Client, visit this guide in order to start using it. Running locally Start local infrastructure: we run Clone this repository: git clone -b js https://github.com/wedeploy/boilerplate-data.git boilerplate-data-js cd boilerplate-data-js Link this container with the local infrastructure: we link Now your container is ready to be used: http://boilerplate-data.wedeploy.me Deploying to the cloud Fork this repository. Go to the Dashboard. Create a project. In the sidebar, click on Deployment. Using your local machine, clone your Github fork: git clone -b js https://github.com//boilerplate-data Get into the folder: cd boilerplate-data. Using the content on Deployment page. Add the WeDeploy remote url: git remote add wedeploy http://git.wedeploy.com/.git Push your data to wedeploy git server: git push wedeploy js:master. Once you see it in the Dashboard, your container will be ready to be used. http://boilerplate-data.wedeploy.io What's next? Now that you have WeDeploy Data API settled up, you can interact configuring the data service. ","srcFilePath":"src/pages/docs/data/getting-started.md","id":"getting-started","url":"/docs/data/getting-started.html"},"real-time-feeds":{"title":"Real-time Feeds","description":"WeDeploy‚Ñ¢ Data inverts the traditional database architecture, instead of polling for changes, the developer can tell WeDeploy Data to continuously push updated query results to applications in real-time.","headerTitle":"Data","layout":"guide","weight":8,"content":" {$page.title} {$page.description} Watching data changes We presented a lot of features for data filtering and search. You may be wondering where the real-time aspect is in all of this. Well, it's throughout the features we just presented to you. To access our data in real-time, all we need to do is change the WeDeploy API get method to use to the watch method: WeDeploy .data('http://datademo.wedeploy.io') .watch('movies') .on('changes', function(data) { console.log(data); }) .on('fail', function(error) { console.log(error); }); // You have to hold a strong reference to the socket or it will be released socket = WeDeploy .data(\"http://datademo.wedeploy.io\") .watch(resourcePath: \"movies\") socket.on([.changes, .error]) { data in switch(data.type) { case .changes: print(\"changes \\(data.document)\") case .error: print(\"error \\(data.document)\") default: break } } Now every time the storage detects changes that affect the query you're watching, you will receive a changes notification with the response body you'd receive if you had done an HTTP GET instead. Furthermore, every time this change leads to an HTTP error response, you'll receive the error object in a fail notification on the client. Watching with advanced filters To present data using advanced search is simple as performing normal queries. You just would need to keep using the watch method and apply any filter you desire. WeDeploy .data('http://datademo.wedeploy.io') .where('category', 'cinema') .or('category', 'cartoon') .watch('movies') .on('changes', function(data) { console.log(data); }) .on('fail', function(error) { console.log(error); }); // You have to hold a strong reference to the socket or it will be released socket = WeDeploy .data(\"http://datademo.wedeploy.io\") .where(field: \"category\", op: \"=\", value: \"cinema\") .or(field: \"category\", op: \"=\", value: \"cartoon\") .watch(resourcePath: \"movies\") socket.on([.changes, .error]) { data in switch(data.type) { case .changes: print(\"changes \\(data.document)\") case .error: print(\"error \\(data.document)\") default: break } } Getting the latest changes The data service uses a query limit 500 by default. In order to always get the latest new record, you would need to limit the query by 1 and order by id desc. WeDeploy .data('http://datademo.wedeploy.io') .limit(1) .orderBy('id', 'desc') .watch('movies') .on('changes', function(data) { console.log(data); }) .on('fail', function(error) { console.log(error); }); // You have to hold a strong reference to the socket or it will be released socket = WeDeploy .data(\"http://datademo.wedeploy.io\") .limit(1) .orderBy(field: \"id\", order: .DESC) .watch(resourcePath: \"movies\") socket.on([.changes, .error]) { data in switch(data.type) { case .changes: print(\"changes \\(data.document)\") case .error: print(\"error \\(data.document)\") default: break } } What's next? Now we're ready to save and retrieve data in real-time. ","srcFilePath":"src/pages/docs/data/real-time-feeds.md","id":"real-time-feeds","url":"/docs/data/real-time-feeds.html"},"retrieving-data":{"title":"Retrieving Data","description":"The get() function retrieve an existing field, document or collection in the database.","headerTitle":"Data","layout":"guide","weight":6,"content":" {$page.title} {$page.description} Get data Reading data from our storage takes only 3 lines of code. WeDeploy .data('http://datademo.wedeploy.io') .get('movies/starwarsv') .then(function(movie) { console.log(movie); }); WeDeploy .data(\"http://datademo.wedeploy.io\"); .get(resourcePath: \"movies/starwarsv\") .then { movie in print(movie) } The response body is the stored JSON document: { \"id\": \"starwarsv\", \"title\": \"Star Wars: Episode V - The Empire Strikes Back\", \"year\": 1980, \"rating\": 8.8 } We can also get any field value using the full path: WeDeploy .data('http://datademo.wedeploy.io') .get('movies/starwarsv/title') .then(function(title) { console.log(title); }); WeDeploy .data(\"http://datademo.wedeploy.io\"); .get(resourcePath: \"movies/starwarsv/title\") .then { (movie: String) in // You have to specify the type here to allow compiler infer type print(movie) } The full path returns the raw content in the response body: Star Wars: Episode V - The Empire Strikes Back Requesting the entire movies collection using curl -X \"GET\" \"http://datademo.wedeploy.io/movies\" results in the first 10 documents stored: [ {\"id\":\"starwarsi\", \"title\":\"Star Wars: Episode I - The Phantom Menace\", \"year\":1999, \"rating\":6.5}, {\"id\":\"starwarsii\", \"title\":\"Star Wars: Episode II - Attack of the Clones\", \"year\":2002, \"rating\":6.7}, {\"id\":\"starwarsiii\", \"title\":\"Star Wars: Episode III - Revenge of the Sith\", \"year\":2005, \"rating\":7.7}, {\"id\":\"starwarsiv\", \"title\":\"Star Wars: Episode IV - A New Hope\", \"year\":1977, \"rating\":8.7}, {\"id\":\"starwarsv\", \"title\":\"Star Wars: Episode V - The Empire Strikes Back\", \"year\":1980, \"rating\":8.8}, {\"id\":\"starwarsvi\", \"title\":\"Star Wars: Episode VI - Return of the Jedi\", \"year\":1983, \"rating\":8.4}, {\"id\":\"starwarsvii\", \"title\":\"Star Wars: Episode VII - The Force Awakens\", \"year\":2015} ] Sorting data The result is ordered by document id, as we can see in the list above. We can select the order of the results by passing a sort parameter, using the following code: WeDeploy .data('http://datademo.wedeploy.io') .orderBy('rating', 'desc') .get('movies') .then(function(movies) { console.log(movies); }); WeDeploy .data(\"http://datademo.wedeploy.io\"); .orderBy(field: \"rating\", order: .DESC) .then { movies in print(movies) } As expected, the result would be the following list: [ {\"id\":\"starwarsv\",\"title\":\"Star Wars: Episode V - The Empire Strikes Back\",\"year\":1980,\"rating\":8.8}, {\"id\":\"starwarsiv\",\"title\":\"Star Wars: Episode IV - A New Hope\",\"year\":1977,\"rating\":8.7}, {\"id\":\"starwarsvi\",\"title\":\"Star Wars: Episode VI - Return of the Jedi\",\"year\":1983,\"rating\":8.4}, {\"id\":\"starwarsiii\",\"title\":\"Star Wars: Episode III - Revenge of the Sith\",\"year\":2005,\"rating\":7.7}, {\"id\":\"starwarsii\",\"title\":\"Star Wars: Episode II - Attack of the Clones\",\"year\":2002,\"rating\":6.7}, {\"id\":\"starwarsi\",\"title\":\"Star Wars: Episode I - The Phantom Menace\",\"year\":1999,\"rating\":6.5}, {\"id\":\"starwarsvii\",\"title\":\"Star Wars: Episode VII - The Force Awakens\",\"year\":2015} ] Notice that because Episode VII has no rating (as it was not released yet), it's sorted as the last document. Applying filters In addition to sorting the results, we can also apply filters using the following code: WeDeploy .data('http://datademo.wedeploy.io') .where('year', '', 8.5) .get('movies') .then(function(movies) { console.log(movies); }); WeDeploy .data(\"http://datademo.wedeploy.io\"); .where(field: \"year\", op: \"\", value: 8.5) .get(resourcePath: \"movies\") .then { movies in print(movies) } The following entries are the result of the above filters: [ {\"id\":\"starwarsiv\",\"title\":\"Star Wars: Episode IV - A New Hope\",\"year\":1977,\"rating\":8.7}, {\"id\":\"starwarsv\",\"title\":\"Star Wars: Episode V - The Empire Strikes Back\",\"year\":1980,\"rating\":8.8} ] Pagination We can also paginate the result using the 'limit' and 'offset' properties. Combining all the tools we've learned so far, we can run a detailed query on our data: WeDeploy .data('http://datademo.wedeploy.io') .where('year', '', 2000) .orderBy('rating') .limit(2) .offset(1) .get('movies') .then(function(movies) { console.log(movies); }); WeDeploy .data(\"http://datademo.wedeploy.io\"); .where(field: \"year\", op: \"","srcFilePath":"src/pages/docs/data/retrieving-data.md","id":"retrieving-data","url":"/docs/data/retrieving-data.html"},"saving-data":{"title":"Saving Data","description":"The create() function creates a new record in the database using the current attributes. It then returns the newly saved object in the Promise response.","headerTitle":"Data","layout":"guide","weight":3,"content":" {$page.title} {$page.description} Inserting new data By default, all the operation access to your database are restricted so only authenticated users can manipulate data. To get started without setting up Authentication, you can configure your rules for public access. To learn more about rules, see configuring rules section. Writing new data is as simple as sending a JSON. WeDeploy .data('http://datademo.wedeploy.io') .create('movies', { \"title\": \"Star Wars IV\", \"year\": 1977, \"rating\": 8.7 }).then(function(movie) { console.log(movie); }); WeDeploy .data(\"http://datademo.wedeploy.io\") .create(resource: \"movies\", object: [ \"title\" : \"Star Wars IV\", \"year\" : 1977, \"ratings\" : 8.7 ]) .then { movie in print(movie) } As you can see, the data api uses Promises to help you to make async requests. This operation will return the newly created document, with the following generated ID: { \"id\":\" \"115992383516607958\", \"title\": \"Star Wars IV\", \"year\": 1977, \"rating\": 8.7 } Generated ID is a string and it's structure may vary. It is also possible to define custom app-specific value for the ID, by simply passing the id field as part of the new document. Inserting multiple data With the same method you're able to create multiple data instead using the method .create multiple times. You just need to use an array instead an object as the second param. WeDeploy .data('http://datademo.wedeploy.io') .create('movies', [ { \"title\": \"Star Wars III\", \"year\": 2005, \"rating\": 8.0 }, { \"title\": \"Star Wars II\", \"year\": 2002, \"rating\": 8.6 } ]).then(function(movies) { console.log(movies); }); WeDeploy .data(\"http://datademo.wedeploy.io\") .create(resource: \"movies\", object: [ [ \"title\" : \"Star Wars III\", \"year\" : 2005, \"ratings\" : 8.0 ], [ \"title\" : \"Star Wars II\", \"year\" : 2002, \"ratings\" : 8.6 ] ]) .then { movie in print(movie) } This operation will return the newly created array of documents, with the following generated IDs: [ { \"id\":\" 115992383516607959\", \"title\": \"Star Wars III\", \"year\": 2005, \"rating\": 8.0 }, { \"id\":\" 115992383516607954\", \"title\": \"Star Wars II\", \"year\": 2002, \"rating\": 8.6 } ] Inserting new fields in an existing collection WeDeploy Data service is really flexible in therms of data structure. You're able to insert new fiels in a collection by adding the new key in the object param. WeDeploy .data('http://datademo.wedeploy.io') .create('movies', [ { \"title\": \"Star Wars I\", \"obs\": \"First in ABC order\", \"year\": 1999, \"rating\": 9.0 } ]).then(function(movie) { console.log(movie); }); WeDeploy .data(\"http://datademo.wedeploy.io\") .create(resource: \"movies\", object: [ \"title\": \"Star Wars I\", \"obs\": \"First in ABC order\", \"year\": 1999, \"rating\": 9.0 ]) .then { movie in print(movie) } This operation will return the newly created document, with the following generated ID: { \"id\":\" 115992383516607954\", \"title\": \"Star Wars I\", \"obs\": \"First in ABC order\", \"year\": 1999, \"rating\": 9.0 } URL scope structure The URL we just created stored a new document in our app's service inside the \"movies\" collection. More information on how to set up this datastore URL can be seen in the section Building APIs. For now, we only need to know that within the path where the data is mounted. The URL will be interpreted as a key that points to a stored resource like the one below: /collectionName/documentId/documentProperty/documentInnerProperty For example, to reference the newly created Star Wars rating, we can use the path: http://data.datademo.wedeploy.me/movies/115992383516607958/rating What's next? Now that you have learned how to create data, you can interact updating data. ","srcFilePath":"src/pages/docs/data/saving-data.md","id":"saving-data","url":"/docs/data/saving-data.html"},"searching-data":{"title":"Searching Data","description":"Advanced queries using search.","headerTitle":"Data","layout":"guide","weight":7,"content":" {$page.title} {$page.description} Search data We did some great stuff with basic data methods, like create, update, and delete JSON documents. We also learned how to retrieve documents with where, sort, and pagination. What if we need more powerful queries with our documents? In WeDeploy you can do a text search, handle user misspellings, and show the number of documents by category with your data, and much more. First take a look at the text search. It's a simple, yet very powerful way to filter our results by a text query. Using the movie database we created before, let's search for a Star Wars movie by the episode title, like \"Revenge of the Sith\". We are not interested if the letter is in upper or lower case, since we are using English connectors like \"of\" and \"the\". We want something flexible enough that it will also work for texts like \"The revenge of the Sith\", or \"Sith's revenge\". Our match operator is flexible enough for both. WeDeploy .data('http://datademo.wedeploy.io') .match('title', \"Sith's revenge\") .get('movies') .then(function(movies) { console.log(movies); }); WeDeploy .data(\"http://datademo.wedeploy.io\") .match(field: \"title\", pattern: \"Sith's revenge\") .get(resourcePath: \"movies\") .then { movies in print(movies) } The result of the match operator query is the following entry: [{\"id\":\"starwarsiii\",\"title\":\"Star Wars: Episode III - Revenge of the Sith\",\"year\":2005,\"rating\":7.7}] We can also use simple text operators in our match: // we can run this WeDeploy .data('http://datademo.wedeploy.io') .match('title', '(jedi | force) -return') .get('movies') .then(function(movies) { console.log(movies); }); // or this WeDeploy .data('http://datademo.wedeploy.io') .match('title', 'awake*') .get('movies') .then(function(movies) { console.log(movies); }); // or even this WeDeploy .data('http://datademo.wedeploy.io') .match('title', 'wakens~') .get('movies') .then(function(movies) { console.log(movies); }); // we can run this WeDeploy .data(\"http://datademo.wedeploy.io\") .match(field: \"title\", pattern: \"(jedi | force) -return\") .get(resourcePath: \"movies\") .then { movies in print(movies) } // or this WeDeploy .data(\"http://datademo.wedeploy.io\") .match(field: \"title\", pattern: \"awake*\") .get(resourcePath: \"movies\") .then { movies in print(movies) } // or even this WeDeploy .data(\"http://datademo.wedeploy.io\") .match(field: \"title\", pattern: \"wakens~\") .get(resourcePath: \"movies\") .then { movies in print(movies) } Any search in the previous example results in the following match: [{\"id\":\"starwarsvii\",\"title\":\"Star Wars: Episode VII - The Force Awakens\",\"year\":2015}] What we did with * can also be done with the prefix operator Filter.prefix('title', 'awake'). The fuzziness we added to 'wakens' using ~, can also be done explicitly with the fuzzy operator Filter.fuzzy('title', 'wakens'). So far we are still just filtering data with filters. We can do so much more than that! If we use 'query search' instead of 'filter' to send those filters to the server, we can also get information about how relevant a document is to a given search, and order our results by this criteria. Let us introduce this with a new filter that allows us to query movies with a title similar to a given text: WeDeploy .data('http://datademo.wedeploy.io') .similar('title', 'The attack an awaken Jedi uses to strike a Sith is pure force!') .search('movies') .then(function(movies) { console.log(movies); }); WeDeploy .data(\"http://datademo.wedeploy.io\") .similar(field: \"title\", query: \"The attack an awaken Jedi uses to strike a Sith is pure force!\") .search(resourcePath: \"movies\") .then { movies in print(movies) } We receive not only the documents that match the filter, but also search metadata: { \"total\": 5, \"documents\": [ { \"title\": \"Star Wars: Episode VII - The Force Awakens\", \"id\": \"starwarsvii\" }, { \"title\": \"Star Wars: Episode V - The Empire Strikes Back\", \"id\": \"starwarsv\" }, { \"title\": \"Star Wars: Episode VI - Return of the Jedi\", \"id\": \"starwarsvi\" }, { \"title\": \"Star Wars: Episode III - Revenge of the Sith\", \"id\": \"starwarsiii\" }, { \"title\": \"Star Wars: Episode II - Attack of the Clones\", \"id\": \"stawwarsii\" } ], \"scores\": { \"starwarsii\": 0.13102644681930542, \"starwarsiii\": 0.13102644681930542, \"starwarsv\": 0.13102644681930542, \"starwarsvi\": 0.13102644681930542, \"starwarsvii\": 0.5241057872772217 }, \"queryTime\": 1 } Notice that the score of the starwarsvii document is bigger than the other matches, indicating its title is more similar to the given filter than the others. The documents in the result are now ordered by the relevance of the document, expressed as a number in the scores metadata, rather than the document's ID. Now we can show not only filtered results, but also order our results by relevance! Want more? Well, let's make things even easier for the user! Adding one entry to the search query, we can automatically highlight the words that matched our query, showing not only how relevant the document is to the search, but also where it matches our criteria. We can do this with small changes in our previous search, using the following code: WeDeploy .data('http://datademo.wedeploy.io') .similar('title', 'The attack an awakened Jedi uses to strike a Sith is pure force!') .highlight('title') .search('movies') .then(function(movies) { console.log(movies); }); WeDeploy .data(\"http://datademo.wedeploy.io\") .similar(field: \"title\", query: \"The attack an awaken Jedi uses to strike a Sith is pure force!\") .highlight(field: \"title\") .search(resourcePath: \"movies\") .then { movies in print(movies) } As you can see in the code below, our keywords are highlighted in the results: { \"total\": 5, \"documents\": [ { \"title\": \"Star Wars: Episode VII - The Force Awakens\", \"id\": \"starwarsvii\" }, { \"title\": \"Star Wars: Episode V - The Empire Strikes Back\", \"id\": \"starwarsv\" }, { \"title\": \"Star Wars: Episode VI - Return of the Jedi\", \"id\": \"starwarsvi\" }, { \"title\": \"Star Wars: Episode III - Revenge of the Sith\", \"id\": \"starwarsiii\" }, { \"title\": \"Star Wars: Episode II - Attack of the Clones\", \"id\": \"starwarsii\" } ], \"scores\": { \"starwarsii\": 0.13102644681930542, \"starwarsiii\": 0.13102644681930542, \"starwarsv\": 0.13102644681930542, \"starwarsvi\": 0.13102644681930542, \"starwarsvii\": 0.5241057872772217 }, \"queryTime\": 1 } The third search feature is also quite simple, but can be applied to generate meaningful statistical information about our data. What if we need to compare the average rating the first three movies received, with the last three movies? We can do that with aggregations, using the following code: WeDeploy .data('http://datademo.wedeploy.io') .lt('year', 1990) .aggregate('Old Movies', 'rating', 'avg') .count() .get('movies') .then(function(aggregation) { console.log(aggregation); }); WeDeploy .data(\"http://datademo.wedeploy.io\") .lt(field: \"year\", value: 1990) .aggregate(name: \"Old movies\", field: \"rating\", op: \"avg\") .count() .get(resourcePath: \"movies\") .then { (aggregation: [String : Any]) in print(aggregation) } The count we added to the query informed the server that we are not interested in the documents themselves, but rather the number of matches and search metadata. The result, in this case, will be the following data: { \"total\": 3, \"queryTime\": 13, \"aggregations\": { \"Old Movies\": 8.633333333333333 } } Cool, right? Simply run another query for the newest movies, and then you'll have the data you need to compare them. There are some additional operators that you might find useful: min, max, sum, histogram, and even a generic stats that returns several statistics over the field. Take a look at the example below to see results using the additional operators: { \"total\": 3, \"queryTime\": 8, \"aggregations\": { \"Old Movies\": { \"average\": 8.633333333333333, \"count\": 3, \"max\": 8.8, \"min\": 8.4, \"name\": \"Old Movies\", \"standardDeviation\": null, \"sum\": 25.9, \"sumOfSquares\": null, \"variance\": null } } } Notice that in order to read and write your service's root path you need to map it with an API endpoint and data flag active. If we want to inform the server of the data type of a collection field before it receives its first document, we can POST/PATCH the data root with the mapping information: WeDeploy .url('http://datademo.wedeploy.io') .post({ \"places\": { \"location\": \"geo_point\" } }); WeDeploy .url(\"http://datademo.wedeploy.io\") .post(body: [ \"places\" : [ \"location\" : \"geo_point\" ] ]) We can never update an already mapped field, but we can map new fields in an existing collection, as we did in the request above. When we manually map our collection, we can use some extra datatypes that are not mapped dynamically: date, geopoint, and geoshape. We will focus on geo_point for this next feature. So, we mapped a field called location, in the collection places, as representing a geolocation point. This means we can operate, filter, and aggregate the places we put in that collection, using geo filters over this field! Let's try something simple: find cinemas close to London's Waterloo Station. To run the search criteria, we'll use the following code: WeDeploy .data('http://datademo.wedeploy.io') .any('category', 'cinema') .distance('location', '51.5031653,-0.1123051', '1mi') .get('places') .then(function(places) { console.log(places); }); WeDeploy .data(\"http://datademo.wedeploy.io\") .any(field: \"category\", value: [\"cinema\"]) .distance(field: \"location\", latitude: 51.5031653, longitude: -0.1123051, distance: .mile(1)) .get(resourcePath: \"places\") .then { places print(places) } Our result is the following matches: [ { \"name\": \"BFI IMAX\", \"location\": \"51.5126928,-0.12052\", \"id\": \"116686224946770924\", \"category\": [ \"cinema\" ] }, { \"name\": \"Cinema Museum\", \"location\": \"51.501661,-0.1177734\", \"id\": \"116686224946770925\", \"category\": [ \"cinema\", \"museum\" ] }, { \"name\": \"Roxy Bar and Screen\", \"location\": \"51.5012603,-0.1146835\", \"id\": \"116686224946770926\", \"category\": [ \"cinema\", \"bar\", \"restaurant\" ] } ] Now we can plug a map to our app, and let users see and filter places, with just a few lines of code. What's next? Now that you have learned how to retrieve data, you can interact with real-time feeds. ","srcFilePath":"src/pages/docs/data/searching-data.md","id":"searching-data","url":"/docs/data/searching-data.html"},"updating-data":{"title":"Updating Data","description":"The update() function updates an existing record in the database using the current attributes. It then returns the newly updated object in the Promise response.","headerTitle":"Data","layout":"guide","weight":4,"content":" {$page.title} {$page.description} Updating existing data By default, all the operation access to your database are restricted so only authenticated users can manipulate data. To get started without setting up Authentication, you can configure your rules for public access. To learn more about rules, see configuring rules section. Updating existing data is as simple as sending a JSON. WeDeploy .data('http://datademo.wedeploy.io') .update('movies/115992383516607958', { \"rating\": 9.1 }).then(function(movie) { console.log(movie); }); WeDeploy .data(\"http://datademo.wedeploy.io\") .update(resourcePath: \"movies/115992383516607958\", updatedAttributes: [ \"rating\": 9.1 ]) .then { movie in print(movie) } As you can see, the data api uses Promises to help you to make async requests. This operation will return the updated document with the new rating: { \"id\":\" 115992383516607958\", \"title\": \"Star Wars IV\", \"year\": 1977, \"rating\": 9.1 } What's next? Now that you have learned how to update data, you can interact deleting data. ","srcFilePath":"src/pages/docs/data/updating-data.md","id":"updating-data","url":"/docs/data/updating-data.html"}},"title":"Data","url":"/docs/data/getting-started.html","icon":"database","weight":3,"content":" ","srcFilePath":"src/pages/docs/data/index.soy","id":"data","location":"/docs/data","childIds":["getting-started","configuring-data","saving-data","updating-data","deleting-data","retrieving-data","searching-data","real-time-feeds"]},"email":{"children":{"checking-status":{"title":"Checking Status","description":"Sending an email is an asynchronous task. Use this API to know if an email was sent or not.","headerTitle":"Email","layout":"guide","weight":3,"content":" {$page.title} {$page.description} Checking Status In order to check if an email was sent or not, we can use the email ID, e.g. 123, and send a GET request to /emails/123/status. WeDeploy .url('http://..wedeploy.io/emails//status') .get() .then(function(response) { console.log('Email status:', response.body()); }) .catch(function(error) { // Some error has happened }); WeDeploy.email('http://..wedeploy.io) .checkEmailStatus(id: \"202605176596079530\") .then { status in print(\"Email status: \\(status)\") } .catch { error in // Some error has happened } ","srcFilePath":"src/pages/docs/email/checking-status.md","id":"checking-status","url":"/docs/email/checking-status.html"},"environment-variables":{"title":"Environment Variables","description":"Use environment variables to control your app.","headerTitle":"Email","layout":"guide","weight":4,"content":" {$page.title} {$page.description} Note: If you are unfamiliar with how you can apply and manage your secret keys, please visit our Environment Variables page. Reference Here is a list of all the environment variable keys you can use with this service. | Key | Description | | - | - | | EMAIL_HOST | Custom SMTP server host | | EMAIL_PORT | Custom SMTP server port | | EMAIL_USERNAME | Custom SMTP server user | | EMAIL_PASSWORD | Custom SMTP server password | | EMAIL_PAUSE | Interval in milliseconds between each email sending | | EMAIL_SSL | Enables SSL/TLS | ","srcFilePath":"src/pages/docs/email/environment-variables.md","id":"environment-variables","url":"/docs/email/environment-variables.html"},"getting-started":{"title":"Getting Started","description":"Send emails asynchronously and check their status using WeDeploy‚Ñ¢ Email","headerTitle":"Email","layout":"guide","weight":1,"content":" Email {$page.description} See Live Demo or read the source code. Install dependencies This section assumes that you already have the WeDeploy CLI installed and Docker running. Make sure to visit the installation guide if you need help setting that up. We also feature code snippets using the API Client, visit this guide in order to start using it. Running locally Start local infrastructure: we run Clone this repository: git clone -b js https://github.com/wedeploy/boilerplate-email.git boilerplate-email-js cd boilerplate-email-js Link this container with the local infrastructure: we link Now your container is ready to be used: http://emaildemo.wedeploy.me Deploying to the cloud Fork this repository. Go to the Dashboard. Create a project. In the sidebar, click on Deployment. Using your local machine, clone your Github fork: git clone https://github.com//boilerplate-email Get into the folder: cd boilerplate-email. Using the content on Deployment page. Add the WeDeploy remote url: git remote add wedeploy http://git.wedeploy.com/.git Push your data to wedeploy git server: git push wedeploy master. Once you see it in the Dashboard, your container will be ready to be used. http://emaildemo.wedeploy.io What's next? That's it! Now we're ready to start sending emails to our users. ","srcFilePath":"src/pages/docs/email/getting-started.md","id":"getting-started","url":"/docs/email/getting-started.html"},"sending-email":{"title":"Sending Email","description":"Send an email asynchronously and its ID will be returned","headerTitle":"Email","layout":"guide","weight":2,"content":" {$page.title} {$page.description} Sending email We can use the API Client to facilitate the process of sending requests to WeDeploy. In order to send emails, we have to make a POST request to /emails passing some required parameters like from, to, and subject: WeDeploy .url('http://..wedeploy.io/emails') .form('from', 'from@domain.com') .form('to', 'to@domain.com') .form('subject', 'Hi there!') .post() .then(function(response) { console.log('Email ID:', response.body()); }) .catch(function(error) { // Some error has happened }); WeDeploy .email('http://..wedeploy.io) .sendEmail(from: self.username, to: self.username, subject: \"subject\", body: \"body\") .then { id in print(\"Email ID: \\(id)\") } .catch { // Some error has happened } As a result, we'll receive an email ID. This doesn't indicate that the email has already sent, it actually just means that it was added to the email queue. See \"checking the email status\" to learn more about email status. Parameters Here is a list of all the email parameters you can pass. Parameter | Type | Description ------------ | ------- | ------------ bcc | string | Bcc recipient email address. Multiple addresses should be defined in multiple parameters. cc | string | Cc recipient email address. Multiple addresses should be defined in multiple parameters. from | string | Sender email address. message | string | HTML content of your email message. Up to 5MB. priority | number | Used by email clients to define a message's importance. From 1 to 5 where '1' is highest and '5' is the lowest priority. replyTo | string | Append a reply-to address to your email message. subject | string | Subject of your email. Up to 1MB. to | string | Recipient email address. Multiple addresses should be defined in multiple parameters. What's next? Now that you sent an email, you can learn how to check on it's status. ","srcFilePath":"src/pages/docs/email/sending-email.md","id":"sending-email","url":"/docs/email/sending-email.html"}},"title":"Email","url":"/docs/email/getting-started.html","icon":"mail-full","weight":4,"content":" ","srcFilePath":"src/pages/docs/email/index.soy","id":"email","location":"/docs/email","childIds":["getting-started","sending-email","checking-status","environment-variables"]},"hosting":{"children":{"custom-error-pages":{"title":"Custom Error Pages","description":"Show error pages that are consistent with your site's style.","headerTitle":"Hosting","layout":"guide","weight":2,"content":" {$page.title} {$page.description} Custom Error Pages When people try to access nonexistent pages on your site, WeDeploy will display a 404 error page. This page follows a template that might not fit to your visual needs. The good news is that you can create custom error pages that are consistent with your site's style. Files put into the special directory /_error are mapped as the error files to be served in case of an error. They must take the form of .html. Check the boilerplate-hosting for a practical example. ","srcFilePath":"src/pages/docs/hosting/custom-error-pages.md","id":"custom-error-pages","url":"/docs/hosting/custom-error-pages.html"},"environment-variables":{"title":"Environment Variables","description":"Use environment variables to control your app.","headerTitle":"Hosting","layout":"guide","weight":3,"content":" {$page.title} {$page.description} Note: If you are unfamiliar with how you can apply and manage your secret keys, please visit our Environment Variables page. Reference Here is a list of all the environment variable keys you can use with this service. | Key | Default Value | Description | | - | - | - | | WEDEPLOYWEBPATH | / | Path to serve static files | | WEDEPLOYWEBERRORPATH | /error | Path to serve error pages | ","srcFilePath":"src/pages/docs/hosting/environment-variables.md","id":"environment-variables","url":"/docs/hosting/environment-variables.html"},"getting-started":{"title":"Getting Started","description":"Serve static files easily using WeDeploy‚Ñ¢ Hosting.","headerTitle":"Hosting","layout":"guide","weight":1,"content":" Hosting {$page.description} See Live Demo or read the source code. Install dependencies This section assumes that you already have the WeDeploy CLI installed and Docker running. Make sure to visit the installation guide if you need help setting that up. Running locally WeDeploy provides a way to run your project locally using a sandbox system. Start local infrastructure: we run Clone this repository: git clone https://github.com/wedeploy/boilerplate-hosting.git cd boilerplate-hosting Link this container with the local infrastructure: we link Now your container is ready to be used: http://hosting..wedeploy.me Inside this project folder, you can find a container.json with the container ID used in this case: hosting. Deploying to the cloud Fork this repository. Go to the Dashboard and create a project. In the sidebar, click on Deployment. Using your local machine, clone your Github fork: git clone https://github.com//boilerplate-hosting Get into the folder: cd boilerplate-hosting. Using the content on Deployment page. Add the WeDeploy remote url: git remote add wedeploy http://git.wedeploy.com/.git Push your data to wedeploy git server: git push wedeploy master. Once you see it in the Dashboard, your container will be ready to be used. http://hosting..wedeploy.io What's next? Now you can learn how to show custom error pages to your users. ","srcFilePath":"src/pages/docs/hosting/getting-started.md","id":"getting-started","url":"/docs/hosting/getting-started.html"}},"title":"Hosting","url":"/docs/hosting/getting-started.html","icon":"folder","weight":5,"content":" ","srcFilePath":"src/pages/docs/hosting/index.soy","id":"hosting","location":"/docs/hosting","childIds":["getting-started","custom-error-pages","environment-variables"]},"intro":{"children":{"configuration-files":{"title":"Understanding Configuration Files","description":"This is an overview of how WeDeploy uses json files to help you to configure your project.","headerTitle":"Intro","layout":"guide","weight":5,"content":" {$page.title} {$page.description} Project file reference The project.json file is a JSON file defining the project attributes. The default path for a project.json is ./project.json. WeDeploy uses this json file to reference to project in case it's already created. If the project does not exist, it creates a new project for you. Supported fields: | Field | Description | | ----- | ----------- | | id | Project unique id. | | name | Project name. | | homeContainer | Service that will be receiving the requests in the base custom domain. | | customDomains | Custom domains used instead the domain generated by wedeploy. | Validations: id: The id must be unique, and you may get an error message in case someone else is already using this project id. customDomains: The custom domain must be unique, and you may get an error message in case someone else is already using this custom domain. Usage: project.json { \"id\": \"projectexample\", \"homeContainer\": \"ui\", \"customDomains\": [\"projectexample.wedeploy.com\"] } Service file reference The container.json file is a JSON file defining the service attributes and configurations. The default path for a container.json is .//container.json. WeDeploy uses this json file to reference to service in case it's already created. If the service does not exist, it creates a new service for you. Supported fields: | Field | Description | | ----- | ----------- | | id | Service unique id. | | type | Service stack/image type. | | hooks | Callbacks that should be executed in the service lifecycle. Currently allowed: build. | | env | Environment variables to be exported in the service lifecycle. | | description | Short information about the service. | Usage: container.json { \"id\": \"conqueror\", \"type\": \"wedeploy/java\", \"description\": \"WeDeploy Service Example\", \"hooks\": { \"build\": \"./gradlew clean build installDist -x test\" }, \"env\": { \"WEDEPLOY_USER\": \"user\" } } ","srcFilePath":"src/pages/docs/intro/configuration-files.md","id":"configuration-files","url":"/docs/intro/configuration-files.html"},"custom-domains":{"title":"Custom Domains","description":"This is an overview of how WeDeploy manages custom domains for your projects.","headerTitle":"Intro","layout":"guide","weight":6,"content":" {$page.title} {$page.description} Introduction To make your app accessible right away, WeDeploy makes any project accessible via its project domain, which looks like ..wedeploy.io. If you have a project named project with a service named web, the WeDeploy project domain would be web.project.wedeploy.io. Every project in WeDeploy supports one or more custom domains. Configuring custom domains WeDeploy can help you to configure your own custom domain, like http://mydomain.com or http://www.mydomain.com. To make a project accessible via one or more non-WeDeploy domain names, you must add custom domain(s) to your project configuration as described below: After create a project on the dashboard. Go to the project settings page. On custom domain session, add the custom domains related to the project. Click in Update Project. Update the domain DNS to point to the project WeDeploy domain (.wedeploy.io). Configuring DNS for root domains A root domain is the highest level of hierarchy for the website you control, ex: mydomain.com. When you register a domain name, you are registering a root domain. This means you have the access to create subdomains and file structures all branching from that root domain. If your DNS provider allows you to either use CNAME or ALIAS records for root domains, you just need to point the CNAME/ALIAS entry for your root domain as described below: | Record | Name | Project Target Domain | | ----------------- | ---------------- | --------------------- | | ALIAS or CNAME| ` or @` | project1.wedeploy.io. | In many DNS Providers, you are only allowed to use Address Records (A) for your root domain. In that case, you can use the static IP provided by WeDeploy as the target for the Address Record (A): | Record | Name | Project Target Domain | | ----------------- | ---------------- | --------------------- | | A | ` or @ | 173.196.61.238` | Configuring DNS for subdomains After configuring the custom domains on the Project Settings, you must point your DNS record to the project WeDeploy domain. You can configure your subdomain as a new CNAME record with your DNS provider. If you're not sure about how to configure CNAME records for subdomains, visit your DNS provider's documentation page. | Record | Subdomain | Project Target Domain | | ----------------- | -------------------- | --------------------- | | CNAME | www.mydomain.com | project1.wedeploy.io. | Configuring DNS for wildcard domain WeDeploy automatically creates a subdomain for each service. Since you typically will have multiple services inside a project, you will either need multiple records, or a single wildcard record. A wildcard record allows you to map all subdomains to your WeDeploy project with a single record. | Record | Subdomain | Project Target Domain | | ----------------- | -------------------- | --------------------- | | CNAME | *.mydomain.com | project1.wedeploy.io. | Result: | WeDeploy Domain | Custom Domain | | ---------------------------- | --------------------- | | service1.project.wedeploy.io | service1.mydomain.com | | service2.project.wedeploy.io | service2.mydomain.com | | service3.project.wedeploy.io | service3.mydomain.com | | service4.project.wedeploy.io | service4.mydomain.com | ","srcFilePath":"src/pages/docs/intro/custom-domains.md","id":"custom-domains","url":"/docs/intro/custom-domains.html"},"environment-variables":{"title":"Environment Variables","description":"This is an overview of how WeDeploy manages environment variables for your projects.","headerTitle":"Intro","layout":"guide","weight":4,"content":" {$page.title} {$page.description} Introduction A project may have numerous environments: a production app, a staging app, and any number of test and local environments maintained by many different developers. However, the code is the same. In order to make it happen, each environment would have specific configurations. A good example would be credentials for the database, where each environment has its own credentials. The ideal scenario for handling this scenario, would be using Environment variables, in order to set up different configurations for different environment using the same code. In a traditional development proccess, you would speciffy the configurations in different files. On WeDeploy you can take advantage of Environment Variables using the dashboard. Configuring environment variables WeDeploy can help you to configure environment variables for your services. Each service can have its own group of environment variables and can be configured follwing these steps: Using the Dashboard 1) Go to the specific Service page. 2) Click on Environment Vars. 3) Add your keys and values. 4) Click on Update Service. Using container.json You can also do this locally by adding the variables to your container.json files like this: { \"id\": \"myapp\", \"type\": \"wedeploy/nodejs\", \"env\": { \"DATABASE_USER\": \"test\", \"DATABASE_NAME\": \"testdb\" } } Note: Any environment variable provided using the dashboard overwrites the environment variables provided in container.json of your service. To see the lists of available variables, go to the Environment Variables page of the individual services: Auth Environment Variables Email Environment Variables Hosting Environment Variables ","srcFilePath":"src/pages/docs/intro/environment-variables.md","id":"environment-variables","url":"/docs/intro/environment-variables.html"},"feature-overview":{"title":"Feature Overview","description":"This is an overview of the features that make WeDeploy easiest way to deploy and scale applications.","headerTitle":"Intro","layout":"guide","weight":2,"content":" {$page.title} {$page.description} Zero downtime upgrades WeDeploy provides automation for updating services and the systems with zero downtime. WeDeploy services can all be updated with rolling, blue-green, or canary deployment patterns. If the update fails, roll it back with a single click. These powerful tools are critical for minimizing downtime and user interruption. Service discovery and load balancing WeDeploy includes several options for automating service discovery and load balancing. Distributed services create distributed problems, but you don‚Äôt have to solve them all yourself. WeDeploy includes automatic DNS endpoint generation, an API for service lookup, transport layer (L4) virtual IP proxying for high speed internal communication, and application layer (L7) load balancing for external-facing services. Service visibility WeDeploy provides an option for you to specify whether your service is going to be public or private for public access. High availability WeDeploy is highly available and makes it easy for your services to be highly available too. Mission-critical services require health monitoring, self-healing, and fault tolerance both for themselves and the platform and infrastructure they run on. WeDeploy gives you multiple layers of protection. To achieve self-healing, WeDeploy services are monitored and restarted when they fail. Even legacy services that don‚Äôt support distribution or replication can be automatically restarted to maximize uptime and reduce service interruption. Elastic scalability WeDeploy gives you the power to easily scale your services up and down with the turn of a dial. Horizontal scaling is trivial in Docker Swarm, as long as your service supports it. You can change the number of service instances at any time. WeDeploy even lets you autoscale the number of instances based on session count, using the WeDeploy Load Balancer. User interfaces WeDeploy offers two interfaces to make it easy to monitor and manage the projects and its services. The WeDeploy Dashboard lets you monitor resource allocation, running services health, and more with intuitive browser-based navigation, real-time graphs, and interactive debugging tools. The WeDeploy Command-line Interface (CLI) provides you control from the comfort of a terminal. It‚Äôs powerful, yet easily scriptable, with handy plugins to interact with installed projects. ","srcFilePath":"src/pages/docs/intro/feature-overview.md","id":"feature-overview","url":"/docs/intro/feature-overview.html"},"using-the-api-client":{"title":"Using the API Client","description":"Make requests to WeDeploy using a standardized interface.","headerTitle":"Intro","layout":"guide","weight":8,"content":" {$page.title} {$page.description} Javascript API Installation In order to send/receive requests to/from WeDeploy, we need to include the JavaScript API Client. This library provides a secure and reliable communication channel with WeDeploy. We can do that by simply adding a script tag in a HTML file: Swift API Installation If you want to send/receive requests to/from WeDeploy from an iOS App, we also have a solution for that, the Swift API Client. In order to start using it you have to do: Cocoapods Add this to your Podfile pod 'WeDeploy' Carthage Add this to your Cartfile github 'wedeploy/api-swift' API nuances By default, all swift api requests returns a promise, for example: WeDeploy .data(\"http://datademo.wedeploy.io\"); .get(resourcePath: \"movies\") .then { movie in print(movie) } But you will be able to return a callback or even an observable! You will have this two methods available: // The method toCallback converts a promise into a callback WeDeploy .data(\"http://datademo.wedeploy.io\"); .get(resourcePath: \"movies\") toCallback { movies, error in // here you can check the error or the response } // The method toObservable converts a promise into an observable WeDeploy .data(\"http://datademo.wedeploy.io\"); .get(resourcePath: \"movies\") .toObservable() .subscribe( onNext: { movies in // here you receive the movies }, onError: { error in // oops something went wrong } ) ","srcFilePath":"src/pages/docs/intro/using-the-api-client.md","id":"using-the-api-client","url":"/docs/intro/using-the-api-client.html"},"using-the-command-line":{"title":"Using the Command-line","description":"The WeDeploy Command-Line Interface is a tool for helping you to use the WeDeploy platform by providing support to things like creating, managing, and scaling applications.","headerTitle":"Intro","layout":"guide","weight":7,"content":" {$page.title} {$page.description} Dependencies The following external software dependencies are necessary to correctly run some commands: a) Git (download for Linux, macOS, Windows) b) Docker (download for Linux, macOS, Windows) Docker version 1.12.0 or later is required. If you use macOS, install the Docker for Mac. If you use Windows, please install Docker for Windows. Docker Toolbox, still available for earlier Mac and Windows systems is not supported. Installing If you use a Unix-like system such as macOS or Linux open your Terminal and run: curl http://cdn.wedeploy.com/cli/latest/wedeploy.sh -sL | bash If you use Windows, you probably want the Windows amd64 installer. For other systems, check a list of all builds available. Check your docker configuration: docker comes with a 2.0GB maximum memory limit by default on macOS and Windows. You should increase this limit to at least 4.0GB. Creating projects locally You are able to organize your services by project. Inside each project you can create services (called containers here), like static hosting, data API, Auth service, etc. Use we create to create projects and containers. You can create a project anywhere on your machine. Containers might be created one directory above a project for your convenience. Usage: we create --project --container Running projects locally For this demo we are going to use the hosting boilerplate. Start local infrastructure: we run Clone this repository: git clone https://github.com/wedeploy/boilerplate-hosting.git cd boilerplate-hosting Link this container to a new project named demo: we link --project demo Now your container should be accessible from http://hosting.demo.wedeploy.me On the first first time it might take a few minutes while downloading the hosting image on the background. Remotes and friendly host style Many commands requires --project, --container, or --remote flags. You can use the following patterns for passing these values: we --project --container and the friendly host style: we .. or even we . --remote For the local cloud, just don't add a --remote or `` value like in: we log public.chat or to list all logs by containers on the project \"chat\": we log chat Remotes can be managed in a similar fashion as git's remote command: $ we remote -v wedeploy wedeploy.io If you know how to use git remote you already know how to use we remote. For your convenience we include the wedeploy cloud remote by default once you log in on the CLI app with we login (requested when necessary). All commands that support --project, --container, and / or --remote support this host style as well. Fetching project and container logs You can fetch projects and container logs with we log --project --container or with a friendly host style like we log ..wedeploy.me Examples: See the logs for the last 20min for the data container on the wechat project: we log --project wechat --container data --since 20min Watch for logs on the hosting container on the demo project: we log hosting.demo.wedeploy.me --watch Listing projects and containers Watch the listing of all projects running locally: we list --watch List all your projects running on the WeDeploy cloud: we list wedeploy.io or we list --remote wedeploy ","srcFilePath":"src/pages/docs/intro/using-the-command-line.md","id":"using-the-command-line","url":"/docs/intro/using-the-command-line.html"},"using-the-dashboard":{"title":"Using the Dashboard","description":"In this section, you'll learn how to deploy an application using WeDeploy Dashboard.","headerTitle":"Intro","layout":"guide","weight":3,"content":" {$page.title} {$page.description} Create an account First you need to create a WeDeploy account by signing up through the dashboard signup page. Access your dashboard As the main page, the dashboard will list all your projects and status of availability in the server. In the Dashboard, click in New Project . Create a new project You are able to organize your services by project. Select a project ID and click in Create Project. Open your project Open your project by clicking on your project domain. Click on install service Projects can have more than one service. In this example we're going to deploy a static website. Select a service type In this tutorial we're going to use the WeDeploy Hosting in order to host a static project. Fill in the ID click on install service The container is going to be up and running Access the URL generated for your service Now that you installed the boilerplate, in the service screen is possible to see the status of the service and its URL. Click on the URL to copy to your clipboard and open that in a new tab in your browser. It works! That's it! Using a sofisticated Loadbalancer system and service discovering, WeDeploy automatically creates a URL and points that to your container. ","srcFilePath":"src/pages/docs/intro/using-the-dashboard.md","id":"using-the-dashboard","url":"/docs/intro/using-the-dashboard.html"},"what-why-and-how":{"title":"What Why and How","description":"Forget about infrastructure. WeDeploy helps you to dedicate your time to what really matters: building and scaling great apps. Before exploring WeDeploy further, make sure you understand its purpose and philosophy.","headerTitle":"Intro","layout":"guide","weight":1,"content":" {$page.title} {$page.description} What's WeDeploy? WeDeploy gives you access to intuitive APIs that can help you create modern apps faster. From simple applications to a full micro service architecture, choose between dozens of languages, frameworks, or entire application stacks and launch production-ready environments in a matter of minutes. With WeDeploy, you are able to quickly and efficiently respond to user demands: Deploy your applications quickly. Automatically distribute incoming traffic across multiple instances. Authenticate users with only a few lines of code. Store data securely and consume information in real-time. Release applications with zero downtime. Build and deploy micro services. Why should I use WeDeploy? When building highly scalable applications there are many things you need to consider: performance bottlenecks, database resiliency and scalability, authentication, authorization, and static hosting to name a few. WeDeploy is a new dynamic Liferay initiative, allowing you to handle all of your back-end challenges in one place. Focus on creating amazing user experiences and WeDeploy will take care of the rest. This is why WeDeploy was also designed to serve as a platform for building a manageable ecosystem of components and tools to make it easier to deploy and scale any application. How will WeDeploy help me to deploy from simple to advanced applications? From a simple application to an advanced group of microservices, WeDeploy will provide the tools to manage the visibility, scale, and DNS for your application. WeDeploy provides an infrastructure to deploy micro-services in a managed cloud infrastructure. ","srcFilePath":"src/pages/docs/intro/what-why-and-how.md","id":"what-why-and-how","url":"/docs/intro/what-why-and-how.html"}},"title":"Intro","url":"/docs/intro/what-why-and-how.html","icon":"arrow-right-rod","weight":1,"content":" ","srcFilePath":"src/pages/docs/intro/index.soy","id":"intro","location":"/docs/intro","childIds":["what-why-and-how","feature-overview","using-the-dashboard","environment-variables","configuration-files","custom-domains","using-the-command-line","using-the-api-client"]},"other":{"title":"Other","url":"/docs/other/liferay.html","icon":"module","weight":6,"content":" ","srcFilePath":"src/pages/docs/other/index.soy","id":"other","location":"/docs/other","children":{"java":{"title":"Getting Started With Java","description":"Launch a Java 8 application in few steps.","headerTitle":"Other","layout":"guide","weight":4,"content":" Java {$page.description} See Live Demo or read the source code. Install dependencies This section assumes that you already have the WeDeploy CLI installed and Docker running. Make sure to visit the installation guide if you need help setting that up. Running locally Start local infrastructure: we run Clone this repository: git clone https://github.com/wedeploy/boilerplate-java.git cd boilerplate-java Build the container: we build Link this container with the local infrastructure: we link --project Now your container is ready to be used: http://java..wedeploy.me Deploying to the cloud Fork this repository. Go to the Dashboard. Create a project. In the sidebar, click on Deployment. Using your local machine, clone your Github fork: git clone https://github.com//boilerplate-java Get into the folder: cd boilerplate-java. Using the content on Deployment page. Add the WeDeploy remote url: git remote add wedeploy http://git.wedeploy.com/.git Push your data to wedeploy git server: git push wedeploy master. Once you see it in the Dashboard, your container will be ready to be used. http://java..wedeploy.io What's next? Now you can start building your Java based application. ","srcFilePath":"src/pages/docs/other/java.md","id":"java","url":"/docs/other/java.html"},"liferay":{"title":"Getting Started With Liferay","description":"Launch a Liferay application in few steps.","headerTitle":"Other","layout":"guide","weight":1,"content":" Liferay {$page.description} See Live Demo or read the source code. Install dependencies This section assumes that you already have the WeDeploy CLI installed and Docker running. Make sure to visit the installation guide if you need help setting that up. Running locally Start local infrastructure: we run Clone this repository: git clone https://github.com/wedeploy/boilerplate-liferay.git cd boilerplate-liferay Link this container with the local infrastructure: we link --project Now your container is ready to be used: http://liferay..wedeploy.me Deploying to the cloud Fork this repository. Go to the Dashboard. Create a project. In the sidebar, click on Deployment. Using your local machine, clone your Github fork: git clone https://github.com//boilerplate-liferay Get into the folder: cd boilerplate-liferay. Using the content on Deployment page. Add the WeDeploy remote url: git remote add wedeploy http://git.wedeploy.com/.git Push your data to wedeploy git server: git push wedeploy master. Once you see it in the Dashboard, your container will be ready to be used. http://liferay..wedeploy.io What's next? Now you can start building your liferay based application. ","srcFilePath":"src/pages/docs/other/liferay.md","id":"liferay","url":"/docs/other/liferay.html"},"nodejs":{"title":"Getting Started With Node.js","description":"Launch a Node.js application in few steps.","headerTitle":"Other","layout":"guide","weight":2,"content":" Node.js {$page.description} See Live Demo or read the source code. Install dependencies This section assumes that you already have the WeDeploy CLI installed and Docker running. Make sure to visit the installation guide if you need help setting that up. Running locally Start local infrastructure: we run Clone this repository: git clone https://github.com/wedeploy/boilerplate-nodejs.git cd boilerplate-nodejs Build the container: we build Link this container with the local infrastructure: we link --project Now your container is ready to be used: http://nodejs..wedeploy.me Deploying to the cloud Fork this repository. Go to the Dashboard. Create a project. In the sidebar, click on Deployment. Using your local machine, clone your Github fork: git clone https://github.com//boilerplate-nodejs Get into the folder: cd boilerplate-nodejs. Using the content on Deployment page. Add the WeDeploy remote url: git remote add wedeploy http://git.wedeploy.com/.git Push your data to wedeploy git server: git push wedeploy master. Once you see it in the Dashboard, your container will be ready to be used. http://nodejs..wedeploy.io Additional Notes As of right now, node.js servers running on WeDeploy only accept connections through port 80. What's next? Now you can start building your Node.js based application. ","srcFilePath":"src/pages/docs/other/nodejs.md","id":"nodejs","url":"/docs/other/nodejs.html"},"ruby":{"title":"Getting Started With Ruby","description":"Launch a Ruby application in few steps.","headerTitle":"Other","layout":"guide","weight":3,"content":" Ruby {$page.description} See Live Demo or read the source code. Install dependencies This section assumes that you already have the WeDeploy CLI installed and Docker running. Make sure to visit the installation guide if you need help setting that up. Running locally Start local infrastructure: we run Clone this repository: git clone https://github.com/wedeploy/boilerplate-ruby.git cd boilerplate-ruby Build the container: we build Link this container with the local infrastructure: we link --project Now your container is ready to be used: http://ruby..wedeploy.me Deploying to the cloud Fork this repository. Go to the Dashboard. Create a project. In the sidebar, click on Deployment. Using your local machine, clone your Github fork: git clone https://github.com//boilerplate-ruby Get into the folder: cd boilerplate-ruby. Using the content on Deployment page. Add the WeDeploy remote url: git remote add wedeploy http://git.wedeploy.com/.git Push your data to wedeploy git server: git push wedeploy master. Once you see it in the Dashboard, your container will be ready to be used. http://ruby..wedeploy.io What's next? Now you can start building your ruby based application. ","srcFilePath":"src/pages/docs/other/ruby.md","id":"ruby","url":"/docs/other/ruby.html"}},"childIds":["liferay","nodejs","ruby","java"]}},"childIds":["intro","auth","data","email","hosting","other"]},"terms":{"title":"Terms of Service","description":"Liferay WeDeploy Alpha Services Agreement","layout":"termsPage","hidden":true,"content":" {$page.description} PLEASE READ THIS AGREEMENT CAREFULLY BEFORE PURCHASING AND/OR USING WEDEPLOY. BY USING WEDEPLOY, END USER SIGNIFIES ITS ASSENT TO AND ACCEPTANCE OF THIS AGREEMENT AND ACKNOWLEDGES IT HAS READ AND UNDERSTANDS THIS AGREEMENT. AN INDIVIDUAL ACTING ON BEHALF OF AN ENTITY REPRESENTS THAT HE OR SHE HAS THE AUTHORITY TO ENTER INTO THIS AGREEMENT ON BEHALF OF THAT ENTITY. IF END USER DOES NOT ACCEPT THE TERMS OF THIS AGREEMENT, THEN IT MUST NOT USE WEDEPLOY. This Liferay WeDeploy Alpha Services Agreement, including all referenced appendices and documents located at URLs (the \"Agreement\"), is between Liferay, Inc. (\"Liferay\") with a principal place of business at 1400 Montefino Ave, Diamond Bar, CA 91765 and the user of WeDeploy (\"WeDeploy\") who accepts the terms of this Agreement (\"You\" or \"End User\"). The effective date of this Agreement is the earlier of the date that End User accepts this Agreement or the date that End User uses WeDeploy (\"Effective Date\"). 1. Definitions \"Account\" means the individual account each End User must create and use to access WeDeploy. \"Acceptable Use Policy\" means the WeDeploy Acceptable Use Policy set forth in Appendix A, attached to this Agreement. \"Affiliate\" means in the case of a company, an entity that owns or controls, is owned or controlled by, or is under common control or ownership with a party, where ‚Äòcontrol‚Äô is the possession, direct or indirect, of the power to direct or cause the direction of the management and policies of an entity, whether though ownership of voting shares, by contract or otherwise. \"Application(s)\" means the web application(s) that an End User creates and makes available through the use of WeDeploy. \"Alpha Term\" means the period of time Liferay makes the \"alpha\" version of WeDeploy available to the general public. \"Content\" means any content or data whether developed in connection with WeDeploy or otherwise, software code, documentation, materials, information, text files, images and/or trademarks associated with Your Account, Application or any other use of WeDeploy and not provided by Liferay. \"Liferay Software and/or Services\" means the software and/or services made available through WeDeploy for End User to build an Application that is owned by, maintained by, or is a community project sponsored by Liferay. \"Privacy Policy\" means Liferay‚Äôs privacy policy set forth at https://www.liferay.com/privacy-policy. \"Service Level\" means the resources allotted per each End User Account within the WeDeploy web service. \"Third Party Software and/or Services\" means the software and/or services made available through WeDeploy for End User to build an Application that is not owned or maintained by Liferay. 2. Accounts An End User is required to create and maintain an Account to access and use Liferay WeDeploy to create Applications by providing a valid email address and creating a password. End Users may not create multiple Accounts to increase the Service Level provided for each End User. Each End User remains fully responsible for any activity through an End User‚Äôs Account. 3. Use Liferay grants End User a non-exclusive, non-assignable, worldwide right to access and use WeDeploy for the Alpha Term solely for the Customer's evaluation and testing of WeDeploy and subject to the terms herein. Each End User is responsible for determining the suitability of WeDeploy for each End User‚Äôs individual use, including with respect to any laws and/or regulations relating to data protection or privacy. After the Alpha Term, WeDeploy may be made available under a separate agreement for use other than solely for evaluation and subject to terms that vary from this Agreement. You understand that Lifeary is not obligated to provide You access to WeDeploy, your Application or your Content after expiration of the Alpha Term. You are responsible for backing up your Application, Content or other data. Liferay‚Äôs provision of the WeDeploy under this Agreement does not require Liferay to meet any service level agreements, promises, or uptimes. Liferay retains all right, title, and interest in WeDeploy. 4. Content Each End User is responsible for the Content made available through use of WeDeploy, including but not limited to the Content‚Äôs compliance with law, the Content‚Äôs compliance with the Acceptable Use Policy, the right to use such Content, and administering take down notices related to the Content. Liferay however reserves the right to suspend or terminate an End User‚Äôs use of or access to WeDeploy immediately and without liability to a End User if any Content breaks any applicable law, requires additional consent or permission a End User has not obtained, or does not comply with the Acceptable Use Policy. An End User may be required upon a reasonable request by Liferay to provide Content or other information as may be reasonably necessary to ensure a End User‚Äôs compliance with the Acceptable Use Policy. End Users are prohibited from using WeDeploy to store, create, or deploy Content that is regulated under the International Traffic in Arms Regulations (ITAR). 5. Third Party Software and Services Certain Third Party Software and/or Services may be made available for use through WeDeploy for an End User to create its own Application(s). Each End User is fully responsible for the choice of any Third Party Software and/or Services within an End User‚Äôs Application. The availability of such Third Party Software and/or Services does not constitute and endorsement by Liferay. The terms and/or conditions that apply to an End User‚Äôs use of any Third Party Software and/or Services within a End User‚Äôs Application are as solely agreed upon between a End User and the Third Party Software and/or Services provider. If an End User chooses to use Third Party Software and/or Services within an End User‚Äôs Application, Liferay may be required to grant the Third Party Software and/or Services provider access to a End User‚Äôs Content or Account to the extent necessary to provide the Third Party Software and/or Services or for interoperability with the Third Party Software and/or Services. Third Party Services may be removed from or no longer available through WeDeploy at any time, for example but not limited to if a take down is required by law or due to inconsistent interoperability. 6. Provision of Services You give Liferay, its Affiliates, subcontractors, and vendors a worldwide, royalty-free, non-exclusive license to (a) host the Content provided by You through Your use of WeDeploy, and (b) display the Content provided by You through Your use of WeDeploy accessible by other users. You represent and warrant that you own all rights in, or have received a valid license to use the Content, with rights or license sufficient to enable any activities in connection with WeDeploy. You must provide all required and appropriate warnings, information and disclosures as may be required due to the nature of the Content. You are solely responsible for backing up Content and otherwise using measures, as You deem necessary to ensure that Content is not lost. 7. Fees There are currently no fees associated with an End Users use of WeDeploy during the Alpha Term. Use of WeDeploy may be subject to fees under a separate agreement upon conclusion of the Alpha Term. 8. Term and Termination This Agreement will terminate upon expiration of the Alpha Term. Sections will survive termination of this agreement. 9. Feedback End Users may choose to submit, including but not limited to, comments, information, feedback, enhancement requests, recommendations, corrections, and ideas regarding Liferay‚Äôs products or services (collectively \"Feedback\") to Liferay in order for Liferay to improve its products and services. If End Users do not want Liferay to improve the products and services using Feedback, please do not submit the Feedback. If you do submit Feedback, Liferay may incorporate such Suggestions as Liferay‚Äôs own into its product and services without any obligation to account to You in any way and Liferay shall be the owner of any products and services it creates as a result of Your Feedback. Liferay may use solutions or technologies that monitor an End Users usage statistics while using WeDeploy. Liferay will only use such usage statistics related to an End User Account in accordance with the Privacy Policy and only to improve WeDeploy or to assist an End User in its use of WeDeploy. 10. Data To provide Liferay WeDeploy to End Users, Liferay may transfer an End User‚Äôs Content or other information between Liferay, its Affiliates, vendors, and/or subcontractors, which may be located worldwide. Liferay‚Äôs Affiliates and/or subcontractors are acting as data processors on behalf of an End User, and may process the Content to provide Liferay WeDeploy. Each End User is responsible for obtaining any necessary consents from users whose sensitive data or other Content is hosted in an End User‚Äôs Application. Any Content or other data used by an End User in an Application an run on Liferay WeDeploy will be subject to and may be used in accordance with the Privacy Policy. Each End User that creates an Application for End Users agrees to protect the privacy of the Application‚Äôs End Users, including implementing appropriate policies and safeguards (that at minimum contain terms substantially similar to those in the Privacy Policy) and notifying such End Users that their data will be stored on facilities accessible to Liferay, its Affiliates, vendors and/or subcontractors. Liferay may provide information including but not limited to Content and information concerning your Account as required by law or to establish or to exercise its legal rights to defend itself against claims without liability. 11. Warranties You represent and warrant that (a) Your use of WeDeploy you will comply with all applicable laws and regulations; (b) You will comply with the Acceptable Use Policy when using WeDeploy; (c) You have the rights in the Content and Application to use such Content and Application with WeDeploy; (d) Your Content and Application do not infringe a third party‚Äôs intellectual property rights (e); You will take all reasonable security precautions when using WeDeploy; and (f) You will not reverse engineer or attempt to reverse engineer WeDeploy. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, WEDEPLOY (INCLUDING ANY SOFTWARE) AS PROVIDED BY LIFERAY AND ITS AFFILIATES ARE PROVIDED AND LICENSED \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTY OF QUALITY, MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE, AND SUCH IMPLIED WARRANTIES, AND ANY OTHER WARRANTIES, REPRESENTATIONS, CONDITIONS AND TERMS, EXPRESS OR IMPLIED (AND WHETHER IMPLIED BY STATUTE, COMMON LAW, COURSE OF DEALING, TRADE USAGE OR OTHERWISE) ARE HEREBY EXCLUDED TO THE FULLEST EXTENT PERMITTED BY LAW. LIFERAY AND ITS AFFILIATES DO NOT GUARANTEE THAT WEDEPLOY OR ANY SOFTWARE OR SERVICES PROVIDED UNDER THIS AGREEMENT HAVE BEEN DESIGNED TO MEET CUSTOMER‚ÄôS SPECIFIC BUSINESS REQUIREMENTS, THE USE OF WEDEPLOY SERVICES OR SOFTWARE WILL BE UNINTERRUPTED OR ERROR FREE, COMPLY WITH LEGAL OR REGULATORY REQUIREMENTS APPLICABLE TO CUSTOMER, OR THAT LIFERAY WILL CORRECT ALL ERRORS. END USER AGREES THAT IT IS SOLELY RESPONSIBLE FOR THE RESULTS OBTAINED FROM THE USE WEDEPLOY SERVICES AND SOFTWARE PROVIDED UNDER THIS AGREEMENT. WITHOUT LIMITING THE GENERALITY OF THE FOREGOING DISCLAIMER, WEDEPLOY SERVICES AND ANY SOFTWARE PROVIDED UNDER THIS AGREEMENT ARE NOT SPECIFICALLY DESIGNED, MANUFACTURED OR INTENDED FOR USE IN (I) FACILITIES OR ENVIRONMENTS REQUIRING FAILSAFE PERFORMANCE, INCLUDING BUT NOT LIMITED TO (A) THE PLANNING, CONSTRUCTION, MAINTENANCE, CONTROL, OR DIRECT OPERATION OF NUCLEAR FACILITIES, (B) AIRCRAFT NAVIGATION, CONTROL OR COMMUNICATION SYSTEMS, WEAPONS SYSTEMS, (C) DIRECT LIFE SUPPORT SYSTEMS OR (II) ULTRA-HAZARDOUS OR STRICT LIABILITY ACTIVITIES AND THE CUSTOMER IS SOLELY RESPONSIBLE AND EXPRESSLY ASSUMES ALL RISK FOR ANY SUCH USE. 12. Limitation of Liability NOTWITHSTANDING ANYTHING TO THE CONTRARY CONTAINED IN THIS AGREEMENT AND TO THE MAXIMUM EXTENT PERMITTED UNDER APPLICABLE LAW, IN NO EVENT WILL LIFERAY OR ITS AFFILIATES HAVE ANY LIABILITY TO END USER AND/OR ITS AFFILIATES, UNDER ANY LEGAL OR EQUITABLE THEORY, WHETHER IN CONTRACT, TORT (INCLUDING, WITHOUT LIMITATION, NEGLIGENCE), PRODUCT LIABILITY, STATUTE OR OTHERWISE, FOR OR IN CONNECTION WITH: (I) ANY ECONOMIC LOSSES, LOSS OF REVENUE, LOSS OF CUSTOMERS OR BUSINESS, LOSS OF OR DAMAGE TO REPUTATION OR GOODWILL, LOSS OF ANTICIPATED PROFITS, LOSS UNDER OR IN RELATION TO ANY OTHER CONTRACT, LOSS OF DATA OR INTERRUPTION OF SERVICES, LOSS OF ANTICIPATED SAVINGS OR BENEFITS, OR COVER OR ANALOGOUS COST RELATED TO THE PROCUREMENT OF REPLACEMENT SERVICES OR SOFTWARE; (II) ANY LOSSES, COSTS, EXPENSES OR DAMAGES ARISING OUT OF OR IN CONNECTION WITH ANY MALFUNCTIONS, REGULATORY NON-COMPLIANCE, DELAYS, PRODUCT LIABILITY, RELIANCE, BREACH OF ANY IMPLIED DUTY; OR (III) ANY LOSSES, COSTS, EXPENSES OR DAMAGES OTHER THAN DIRECT DAMAGES, INCLUDING WITHOUT LIMITATION, ANY INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, CONSEQUENTIAL OR PUNITIVE DAMAGES, LOSSES, COSTS OR EXPENSES. IN EACH CASE (I) THROUGH (III), WHETHER OR NOT FORESEEABLE; EVEN IF A PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, LOSSES, COSTS OR EXPENSES. FOR ALL EVENTS AND CIRCUMSTANCES AND TO THE MAXIMUM EXTENT PERMITTED UNDER APPLICABLE LAW, THE AGGREGATE AND CUMULATIVE LIABILITY OF LIFERAY AND ITS AFFILIATES TO THE OTHER PARTY AND/OR ITS AFFILIATES ARISING OUT OF OR RELATING TO THIS AGREEMENT, INCLUDING WITHOUT LIMITATION ON ACCOUNT OF PERFORMANCE OR NON-PERFORMANCE OF OBLIGATIONS, REGARDLESS OF THE FORM OF THE CAUSE OF ACTION, WHETHER IN CONTRACT, TORT (INCLUDING, WITHOUT LIMITATION, NEGLIGENCE), STATUTE OR OTHERWISE WILL NOT EXCEED FIFTY UNITED STATES DOLLARS ($50). 13. Indemnification If a third party makes a claim against Liferay or its Affiliates that Your Application, Content or other use of WeDeploy infringes any patent, copyright or trademark, or misappropriates any trade secret, then You shall indemnify and defend Liferay, its Affiliates, its directors, officers and employees against such a claim at Your expense and You shall pay all losses, damages and expenses (including reasonable attorneys' fees) finally awarded against such parties or agreed to in a written settlement agreement signed by Liferay and/or its Affiliates, to the extent arising from the claim. 14. Governing Law; Jurisdiction The validity, interpretation and enforcement of this Agreement (and any dispute or claim relating to it, or its formation, existence, construction, performance or termination) will be governed by and construed in accordance with the laws of the United States and of the State of California without giving effect to the conflicts of laws provisions thereof or the United Nations Convention on Contracts for the International Sale of Goods. All disputes or claims arising out of or relating to this Agreement or its subject matter will be submitted to the exclusive jurisdiction of the state or federal courts of competent jurisdiction located in Los Angeles County, California and each party irrevocably consents to such personal jurisdiction and waives all objections to this venue. In the event the Uniform Computer Information Transactions Act (UCITA) or any similar federal or state laws or regulations are enacted, it will not apply to this Agreement, and the governing law will remain as if such law or regulation had not been enacted. 15. Notices All notices to Liferay permitted or required under this Agreement shall be in English, in writing and shall be delivered in person, by certified or registered express mail, by other nationally recognized overnight delivery service, electronic mail, or facsimile. Notices shall be deemed received the day of personal delivery, or in relation to transmission by electronic mail, at the time at which the notice enters an information system which is under the control of the recipient or in relation to facsimile, on receipt by the sender of an acknowledgment or transmission report generated by the machine from which the facsimile was sent that the facsimile was successfully sent in its entirety or five (5) days after deposit in the mail or with a nationally recognized overnight delivery service. End Users shall direct all notices to Liferay under this Agreement to the following address: Liferay, Inc., Attn: Legal Department, 1400 Montefino Avenue, Diamond Bar, California 91765; E-mail: legal@liferay.com; FAX: (866) 497-9792. All notices to End Users permitted or required under this Agreement shall be addressed to the e-mail address associated with an End Users Account and shall be deemed received immediately after being sent to the e-mail address provided to Liferay. 16. Assignment You may not assign this Agreement or any of its rights or obligations under this Agreement without the Liferay‚Äôs prior written consent. Liferay may assign this Agreement or any of its rights or obligations under this agreement (i) to any Affiliate, or (ii) in connection with any sale, transfer, or other disposition of all or substantially all of its business or assets. 17. Force Majeure Neither party shall be liable to the other for failure or delay in the performance of a required obligation under this Agreement if such failure or delay is caused by acts of God, wars, riots, strikes, fire, terrorist acts, flood, explosion, failure or diminishment of power or of telecommunications or data networks or services, earthquake or other natural disaster, government regulation, or other similar cause beyond such party's reasonable control. 18. Headings Headings to the sections of this Agreement are for convenience only and shall not have any effect on construction and interpretation of this Agreement. No provision shall be construed adversely to a party solely on the ground that the party was responsible for the preparation of this Agreement or that provision 19. Entire Agreement This agreement contains all the terms agreed to by the parties relating to its subject matter. It replaces all previous discussions, understandings, and agreements. 20. Severability If any part of this agreement is declared unenforceable or invalid, the remainder will continue to be valid and enforceable. 21. Waiver A party's failure or neglect to enforce any of rights under this agreement will not be deemed to be a waiver of that party's rights. 22. Waiver of Jury Trial TO THE FULLEST EXTENT PERMITTED BY APPLICABLE LAW, EACH PARTY WAIVES THE RIGHT TO TRIAL BY JURY IN ANY LEGAL PROCEEDING ARISING OUT OF OR RELATING TO THIS AGREEMENT OR THE TRANSACTIONS CONTEMPLATED UNDER THIS AGREEMENT. 23. Agreement Updates Liferay reserves the right to update this Agreement from time to time by posting an updated version no later than thirty (30) days prior to the posted effective date of such update. Your continued use and access of WeDeploy after the posted effective date signifies your acceptance to the updated Agreement. Appendix A: WeDeploy Acceptable Use Policy 1. Content Your use of WeDeploy is subject to all applicable laws and regulations, and You agree not to violate such laws and/or regulations. In addition, You agree not to insert, upload, contribute, share, post, distribute, transmit or otherwise promote or facilitate Content that, including but not limited to: (a) is illegal; (b) violates, misappropriates or infringes the third party intellectual property rights of others; (c) solicits, encourages, or promotes use of illegal substances or activities; (d) is threatening, abusive, harassing, defamatory, slanderous, libelous, derogatory, or violent; (e) is invasive of a third party‚Äôs legal rights, including privacy or publicity rights; (f) is vulgar, obscene, bigoted, hateful, or that advocates racial or ethnic intolerance; (g) is profane, scandalous, pornographic, indecent, or otherwise objectionable; (h) is malicious or contains technology that may damage, interfere with, or intercept any system, program or data, including viruses, trojan horses, worms, time bombs or other harmful or disruptive components. 2. Conduct Liferay provides access to WeDeploy for use and purposes in conformance with applicable documentation and/or as otherwise generally described by Liferay and not for interfering with other users enjoyment of WeDeploy or to harass other users or third parties. You are prohibited from conduct, including but not limited to: (a) using WeDeploy for any act or action that gives rise to civil or criminal liability for Yourself or for Liferay or otherwise violates any applicable law or regulation; (b) engaging in any activity that inappropriately restricts or inhibits any other user from using or enjoying WeDeploy, including hacking, cracking, spoofing, or defacing any portion of WeDeploy; (c) posting, distributing, or transmitting chain letters, mass mailings, spam mail, any robot, spider, site search/retrieval application, or other manual or automatic device or process to retrieve or index data or \"data mine\"; (d) harvesting or collecting information about other WeDeploy users without their express written consent; (e) interfering with others‚Äô use and enjoyment of WeDeploy, including intentionally attempting to overload any portion of WeDeploy; (f) launching or facilitating a denial of service attack from or on WeDeploy or (g) using WeDeploy in connection with illegal or unlawful sharing. 3. Security You may not use WeDeploy in any manner that would comprise or violate the security of WeDeploy or other users of WeDeploy, including but not limited to: (a) accessing or using WeDeploy in violation of law, any applicable terms and conditions, or without permission, attempting to test the vulnerability of the security of WeDeploy or to breach any of the security measures of WeDeploy; (b) imitating or impersonating another person or his or her email address or creating false accounts intended to misrepresent yourself or the source of your email; (c) intercepting or monitoring activity on WeDeploy without permission or (d) using any means to circumvent the security limitations of WeDeploy. 4. Reporting Liferay encourages You to report violations of this Acceptable Use Policy to Liferay. Liferay has the right, but not the obligation, to monitor Your activity and Content to determine Your compliance with this Acceptable Use Policy. Liferay has the right in its sole discretion to monitor your activity and Content within any part of WeDeploy accessible to other users such as chat rooms or discussion forums to determine compliance with this Acceptable Use Policy. Liferay has the right in its sole discretion to edit, refuse to post or remove any material submitted to or posted on a Liferay website or WeDeploy that Liferay finds to be in violation of this Acceptable Use Policy or is otherwise objectionable. You are solely responsible for Your activities and any Content You post, transmit, or otherwise make available on a Liferay website or WeDeploy. You acknowledge and agree that Liferay does not have any liability for any action or inaction with respect to your Conduct, communication or posting on a Liferay website or WeDeploy. Liferay may report any activity Liferay believes may violate any law to law enforcement, regulators, or other relevant third parties. 5. Trademarks The trademarks, trade names, service marks and logos of Liferay, Liferay‚Äôs Affiliates and third parties used in the Liferay websites and other WeDeploy (\"Trademarks\") are the property of Liferay, Liferay‚Äôs Affiliates or the third parties. You have no right to use any such Trademarks, and nothing contained in WeDeploy or this Policy grants any right to use (by implication, waiver, estoppel or otherwise) any Trademarks without the prior written permission of Liferay, Liferay‚Äôs Affiliate or the respective third party owner. Please see www.liferay.com/trademark. 6. Linking You may encounter links to non-Liferay sites or services while using WeDeploy, which should not be interpreted as endorsement of Liferay of such third party sites or the company, products, services or content to which they link as such sites are not under Liferay control and Liferay is not responsible for the content of any linked site or any link contained in a linked site. If You decide to access any third party site, product or service linked through WeDeploy, you do so at your own risk. 7. Updates Liferay reserves the right to update this Policy from time to time by posting an updated version no later than thirty (30) days prior to the posted effective date of such update. Your continued use and access of WeDeploy after the posted effective date signifies your acceptance to the updated Policy. ","srcFilePath":"src/pages/terms/index.md","id":"terms","url":"/terms"},"tutorials":{"description":"Tutorials description","title":"Tutorials","tutorialTitle":"Lorem Tutorials Ipsum","url":"/tutorials/hosting/getting-started.html","hidden":true,"content":" ","srcFilePath":"src/pages/tutorials/index.soy","id":"tutorials","location":"/tutorials","children":{"auth-js":{"children":{"clone-sample":{"buttonTitle":"I cloned the sample repo!","description":"In this section, you'll learn how to enable WeDeploy Auth on your application.","layout":"tutorial","parentId":"auth-js","time":5,"title":"Cloning the sample repo","tutorialTitle":"Getting started with WeDeploy Auth using Javascript","weight":2,"content":" Cloning the sample repo To start, you need to create a new project on your WeDeploy dashboard, if you have not already (trying to migrate this tutorial with other tutorials will result in file conflict). Next we will download a sample repo with the necessary files to get us started. To download, run this command in your terminal: git clone https://github.com/jonnilundy/tutorial-auth-js.git **After the tutorial, you are free to push your own files or start from scratch with a new project. ","srcFilePath":"src/pages/tutorials/auth-js/clone-sample.md","id":"clone-sample","url":"/tutorials/auth-js/clone-sample.html"},"deploy":{"buttonTitle":"My service is live!","description":"In this section, you'll learn how to enable WeDeploy Auth on your application.","layout":"tutorial","parentId":"auth-js","time":5,"title":"Deploying your service","tutorialTitle":"Getting started with WeDeploy Auth using Javascript","weight":9,"content":" Deploying your project Now its time to push these local files to your WeDeploy project. First, add a git remote. Within tutorial-auth-js on your command line, run git remote add wedeploy http://git.wedeploy.com/.git. Then make a first commit. git add . git commit -m \"Awesome commit\" git push wedeploy master Go to the WeDeploy dashboard and select your project. On the right you should see the build log of your recent commit. Once it says \"Deploy was successful\" go to .wedeploy.io. Voil√†! Your page is live! ","srcFilePath":"src/pages/tutorials/auth-js/deploy.md","id":"deploy","url":"/tutorials/auth-js/deploy.html"},"email-and-password":{"buttonTitle":"I added the Email and Password script!","description":"In this section, you'll learn how to enable WeDeploy Auth on your application.","layout":"tutorial","parentId":"auth-js","time":3,"title":"Adding Email and Password","tutorialTitle":"Getting started with WeDeploy Auth using Javascript","weight":5,"content":" Adding Email and Password Now that we have Auth initialized on our project, we need to add a script for our email and password login. Underneath the previous script in main.js, paste: function signInWithEmailAndPassword() { auth.signInWithEmailAndPassword(signIn.email.value, signIn.password.value) .then(function() { alert('Sign-in successfully.'); signIn.reset(); }) .catch(function() { alert('Sign-in failed.'); signIn.reset(); }); } signInWithEmailAndPassword is part of the WeDeploy Auth API that allows you to set form inputs as the email and password values of the authentication. ","srcFilePath":"src/pages/tutorials/auth-js/email-and-password.md","id":"email-and-password","url":"/tutorials/auth-js/email-and-password.html"},"getting-started":{"buttonTitle":"I'm ready to start!","description":"In this section, you'll learn how to enable WeDeploy Auth on your application.","layout":"tutorial","parentId":"auth-js","time":5,"title":"Getting Started","tutorialTitle":"Getting started with WeDeploy Auth using Javascript","weight":1,"content":" Getting Started You are here because you just finished installing the Auth service on your project. In this tutorial you will learn how to setup a test environment for your project using our sample files and how to deploy the Auth service using Javascript. What to expect How to setup your machine as a local dev environment How to create the necessary files for your Auth container How to setup email/password authentication How to push your service into deployment What you'll need Git (download for Linux, macOS, Windows) Docker (download for Linux, macOS, Windows) WeDeploy CLI For linux systems, open your Terminal and run: curl http://cdn.wedeploy.com/cli/latest/wedeploy.sh -sL | bash For Windows, you probably want the Windows amd64 installer For other systems, cehck the list of all builds available ","srcFilePath":"src/pages/tutorials/auth-js/getting-started.md","id":"getting-started","url":"/tutorials/auth-js/getting-started.html"},"github":{"buttonTitle":"I added the Github script!","description":"In this section, you'll learn how to enable WeDeploy Auth on your application.","layout":"tutorial","parentId":"auth-js","time":3,"title":"Adding GitHub","tutorialTitle":"Getting started with WeDeploy Auth using Javascript","weight":6,"content":" Adding GitHub You added email and password authentication but what if you want to give your users the option of logging in with their GitHub credentials? Underneath the email and password script in main.js, paste: function signInWithGithub() { var githubProvider = new auth.provider.Github(); githubProvider.setProviderScope('user:email'); auth.signInWithRedirect(githubProvider); } signInWithRedirect allows the user to be redirected to GitHub in order to verify their login information and then redirected back to your app's authentication. ","srcFilePath":"src/pages/tutorials/auth-js/github.md","id":"github","url":"/tutorials/auth-js/github.html"},"google":{"buttonTitle":"I added the Google script!","description":"In this section, you'll learn how to enable WeDeploy Auth on your application.","layout":"tutorial","parentId":"auth-js","time":3,"title":"Adding Google","tutorialTitle":"Getting started with WeDeploy Auth using Javascript","weight":7,"content":" Adding Google You added GitHub authentication but what if you want to give your users the option of logging in with their Google credentials? Underneath the GitHub script in main.js, paste: function signInWithGoogle() { var googleProvider = new auth.provider.Google(); googleProvider.setProviderScope('email'); auth.signInWithRedirect(googleProvider); } Just like GitHub, signInWithRedirect allows the user to be redirected to Google in order to verify their login information and then redirected back to your app's authentication. ","srcFilePath":"src/pages/tutorials/auth-js/google.md","id":"google","url":"/tutorials/auth-js/google.html"},"initialize-auth":{"buttonTitle":"I initialized the Auth service!","description":"In this section, you'll learn how to enable WeDeploy Auth on your application.","layout":"tutorial","parentId":"auth-js","time":3,"title":"Initializing Auth","tutorialTitle":"Getting started with WeDeploy Auth using Javascript","weight":4,"content":" Initializing the Auth Service Now that we have the sample files cloned and the local environemnt running, we can initialize our Authentication. First go to the tutorial-auth-js directory that we cloned and create a file named main.js. This file will contain our Authentication scripts. Inside of main.js, add: WeDeploy.auth('auth.tutorial-auth-js.wedeploy.io') ","srcFilePath":"src/pages/tutorials/auth-js/initialize-auth.md","id":"initialize-auth","url":"/tutorials/auth-js/initialize-auth.html"},"running-locally":{"buttonTitle":"My local environment is running!","description":"In this section, you'll learn how to enable WeDeploy Auth on your application.","layout":"tutorial","parentId":"auth-js","time":3,"title":"Running locally","tutorialTitle":"Getting started with WeDeploy Auth using Javascript","weight":3,"content":" Running locally WeDeploy provides a dev environment for you to run and test your app before pushing it to production. Lets get that running for this project! In your terminal, go to tutorial-auth-js and run we dev. You can now go to http://tutorial-auth-js.wedeploy.me in your browser and see the local deployment of your project. Any changes you make to your project folder now will automatically be deployed to this local server. ","srcFilePath":"src/pages/tutorials/auth-js/running-locally.md","id":"running-locally","url":"/tutorials/auth-js/running-locally.html"},"test":{"buttonTitle":"I tested the Auth!","description":"In this section, you'll learn how to enable WeDeploy Auth on your application.","layout":"tutorial","parentId":"auth-js","time":3,"title":"Testing the Auth","tutorialTitle":"Getting started with WeDeploy Auth using Javascript","weight":8,"content":" Testing the Auth We added email and password, GitHub, and Google authentication. Now lets insert an alert function (simply for testing purposes) so we can make sure our Auth is working. Paste this code into the bottom of your main.js: auth.onSignIn(function(user) { alert('Signed-in ' + user.email); }); Now go back to your homepage and try logging in again. If you see an alert that says Signed-in then it is working! ","srcFilePath":"src/pages/tutorials/auth-js/test.md","id":"test","url":"/tutorials/auth-js/test.html"}},"description":"In this section, you'll learn how to enable WeDeploy Auth on your application.","title":"Javascript Auth Tutorial","tutorialTitle":"Getting started with WeDeploy Authentication using Javascript","url":"/tutorials/auth-js/getting-started.html","hidden":true,"content":" ","srcFilePath":"src/pages/tutorials/auth-js/index.soy","id":"auth-js","location":"/tutorials/auth-js","childIds":["getting-started","clone-sample","running-locally","initialize-auth","email-and-password","github","google","test","deploy"]},"data-js":{"children":{"add-files":{"buttonTitle":"I added the files!","description":"In this section, you'll learn how to enable WeDeploy Data on your application.","layout":"tutorial","parentId":"data-js","time":3,"title":"Create files","tutorialTitle":"Getting started with WeDeploy Data using Javascript","weight":3,"content":" Create files Now that we have the sample files, we can setup our data container. First go to tutorial-data-js and create a directory named data. Inside of that directory, we will create a container.json file and an api.json file. Container.json Create a new file named container.json. This file will designate the id and type of service you are using. Within that file, add: { \"id\": \"data\", \"type\": \"wedeploy/data\" } id is the custom name designated for this service. In future projects, feel free to change this value to whatever best describes your service. type tells WeDeploy what service to use. api.json Now that you have told WeDeploy what type of service to use and what to call it, you need to designate where you want WeDeploy to store your data. Create a new file and name it api.json. Then add: [ { \"path\": \"/tasks/*\", \"data\": true } ] path designates which collection you will be saving and fetching data from. If you want to access all collections on a project, then put {literal}\"/*\"{/literal}. data tells the service if the request to a collection should be stored or not. ","srcFilePath":"src/pages/tutorials/data-js/add-files.md","id":"add-files","url":"/tutorials/data-js/add-files.html"},"clone-sample":{"buttonTitle":"I cloned the sample repo!","description":"In this section, you'll learn how to enable WeDeploy Data on your application.","layout":"tutorial","parentId":"data-js","time":5,"title":"Cloning the sample repo","tutorialTitle":"Getting started with WeDeploy Data using Javascript","weight":2,"content":" Cloning the sample repo To start, you need to create a new project on your WeDeploy dashboard, if you have not already (trying to migrate this tutorial with other tutorials will result in file conflict). Next we will download a sample repo with the necessary files to get us started. To download, run this command in your terminal: git clone https://github.com/jonnilundy/tutorial-data-js.git After the tutorial, you are free to push your own files or start from scratch with a new project. ","srcFilePath":"src/pages/tutorials/data-js/clone-sample.md","id":"clone-sample","url":"/tutorials/data-js/clone-sample.html"},"deploying":{"buttonTitle":"My service is live!","description":"In this section, you'll learn how to enable WeDeploy Data on your application.","layout":"tutorial","parentId":"data-js","time":5,"title":"Deploying your service","tutorialTitle":"Getting started with WeDeploy Data using Javascript","weight":7,"content":" Deploying your project Now its time to push these local files to your WeDeploy project. First, add a git remote. Within tutorial-data-js on your command line, run git remote add wedeploy http://git.wedeploy.com/.git. Then make a first commit. git add . git commit -m \"Awesome commit\" git push wedeploy master Go to the WeDeploy dashboard and select your project. On the right you should see the build log of your recent commit. Once it says \"Deploy was successful\" go to .wedeploy.io. Voil√†! Your page is live! ","srcFilePath":"src/pages/tutorials/data-js/deploying.md","id":"deploying","url":"/tutorials/data-js/deploying.html"},"get-data":{"buttonTitle":"I see the to-do list!","description":"In this section, you'll learn how to enable WeDeploy Data on your application.","layout":"tutorial","parentId":"data-js","time":3,"title":"Get Data","tutorialTitle":"Getting started with WeDeploy Data using Javascript","weight":6,"content":" Get Data We fixed the submit button so that it saved the item descriptions, but our list still is not working. Let's fix that! Open tutorial-data-js/hosting/list.js in your text editor. Right bellow WeDeploy on line 5, input this code that will get the inputted tasks and append them to the list. .data('http://data.tutorial-data-js.wedeploy.io') .orderBy('id', 'desc') .limit(5) .get('tasks') .then(function(response) { appendTasks(response); }) .catch(function(error) { console.error(error); }); Now revisit the \"Go to item listing\" page in your browser and refresh. You should now see the list of items, including your previous entry. To see the power of real-time data, open the list and homepage in seperate windows side-by-side so you can watch both. Add a new item to the homepage and see it automatically update the list in real-time. ","srcFilePath":"src/pages/tutorials/data-js/get-data.md","id":"get-data","url":"/tutorials/data-js/get-data.html"},"getting-started":{"buttonTitle":"I'm ready to start!","description":"In this section, you'll learn how to enable WeDeploy Data on your application.","layout":"tutorial","parentId":"data-js","time":5,"title":"Getting Started","tutorialTitle":"Getting started with WeDeploy Data using Javascript","weight":1,"content":" Getting Started You are here because you just finished installing the Data service on your project. In this tutorial you will learn how to setup a test environment for your project using our boilerplate and how to deploy the Data service using Javascript. What to expect How to setup your machine as a local dev environment How to create the necessary files for your containers How to run your service locally How to push your service into deployment What you'll need Git (download for Linux, macOS, Windows) Docker (download for Linux, macOS, Windows) WeDeploy CLI For linux systems, open your Terminal and run: curl http://cdn.wedeploy.com/cli/latest/wedeploy.sh -sL | bash For Windows, you probably want the Windows amd64 installer For other systems, cehck the list of all builds available ","srcFilePath":"src/pages/tutorials/data-js/getting-started.md","id":"getting-started","url":"/tutorials/data-js/getting-started.html"},"running-locally":{"buttonTitle":"My local environment is running!","description":"In this section, you'll learn how to enable WeDeploy Data on your application.","layout":"tutorial","parentId":"data-js","time":5,"title":"Running locally","tutorialTitle":"Getting started with WeDeploy Data using Javascript","weight":4,"content":" Running locally WeDeploy provides a dev environment for you to run and test your app before pushing it to production. Lets get that running for this project! In your terminal, go to tutorial-data-js and run we dev. You can now go to http://tutorial-data-js.wedeploy.me in your browser and see the local deployment of your project. Any changes you make to your project folder now will automatically be deployed to this local server. ","srcFilePath":"src/pages/tutorials/data-js/running-locally.md","id":"running-locally","url":"/tutorials/data-js/running-locally.html"},"save-data":{"buttonTitle":"I see the new tasks in the console!","description":"In this section, you'll learn how to enable WeDeploy Data on your application.","layout":"tutorial","parentId":"data-js","time":3,"title":"Save Data","tutorialTitle":"Getting started with WeDeploy Data using Javascript","weight":5,"content":" Save Data As you may of noticed, the \"Add Item\" button is not working and the list is not being populated with data. Lets start by making the button save data. Open tutorial-data-js/hosting/index.js in your text editor. Right bellow WeDeploy on line 6, input this code that will create a new item when you click \"Add Item\" and save it to your tasks data collection. .data('http://data.tutorial-data-js.wedeploy.io') .create('tasks', {name: form.item.value }) .then(function(response) { form.reset(); form.item.focus(); console.info('Saved:', response); }) .catch(function(error) { console.error(error); }); Now go back to the homepage and open up the console (Mac: ‚å•‚åò+J, Windows: Ctrl+Shift+J). Type a new task and click \"Add Item\". You should see a new log in the console bellow that looks something like {literal}Saved: Object {name: \"Your Item\", id: \"209513589\"}{/literal}. This means our submit function is working. ","srcFilePath":"src/pages/tutorials/data-js/save-data.md","id":"save-data","url":"/tutorials/data-js/save-data.html"}},"description":"In this section, you'll learn how to enable WeDeploy Data on your application.","title":"Javascript Data Tutorial","tutorialTitle":"Getting started with WeDeploy Data using Javascript","url":"/tutorials/data-js/getting-started.html","hidden":true,"content":" ","srcFilePath":"src/pages/tutorials/data-js/index.soy","id":"data-js","location":"/tutorials/data-js","childIds":["getting-started","clone-sample","add-files","running-locally","save-data","get-data","deploying"]},"email-js":{"children":{"add-files":{"buttonTitle":"I added the files!","description":"In this section, you'll learn how to enable WeDeploy Email on your application.","layout":"tutorial","parentId":"email-js","time":3,"title":"Create files","tutorialTitle":"Getting started with WeDeploy Email using Javascript","weight":3,"content":" Create files Now that we have the sample files, we can setup our email container. First go to tutorial-email-js and create a directory named email. Within that directory, create a new file named container.json. This file will designate the id and type of service you are using. Inside of that file, add: { \"id\": \"email\", \"type\": \"wedeploy/email\" } id is the custom name designated for this service. In future projects, feel free to change this value to whatever best describes your service. type tells WeDeploy what service to use. ","srcFilePath":"src/pages/tutorials/email-js/add-files.md","id":"add-files","url":"/tutorials/email-js/add-files.html"},"clone-sample":{"buttonTitle":"I cloned the sample repo!","description":"In this section, you'll learn how to enable WeDeploy Email on your application.","layout":"tutorial","parentId":"email-js","time":5,"title":"Cloning the sample repo","tutorialTitle":"Getting started with WeDeploy Email using Javascript","weight":2,"content":" Cloning the sample repo To start, you need to create a new project on your WeDeploy dashboard, if you have not already (trying to migrate this tutorial with other tutorials will result in file conflict). Next we will download a sample repo with the necessary files to get us started. To download, run this command in your terminal: git clone https://github.com/jonnilundy/tutorial-email-js.git **After the tutorial, you are free to push your own files or start from scratch with a new project. ","srcFilePath":"src/pages/tutorials/email-js/clone-sample.md","id":"clone-sample","url":"/tutorials/email-js/clone-sample.html"},"deploying":{"buttonTitle":"My service is live!","description":"In this section, you'll learn how to enable WeDeploy Email on your application.","layout":"tutorial","parentId":"email-js","time":5,"title":"Deploying your service","tutorialTitle":"Getting started with WeDeploy Email using Javascript","weight":6,"content":" Deploying your project Now its time to push these local files to your WeDeploy project. First, add a git remote. Within tutorial-email-js on your command line, run git remote add wedeploy http://git.wedeploy.com/.git. Then make a first commit. git add . git commit -m \"Awesome commit\" git push wedeploy master Go to the WeDeploy dashboard and select your project. On the right you should see the build log of your recent commit. Once it says \"Deploy was successful\" go to .wedeploy.io. Voil√†! Your page is live! ","srcFilePath":"src/pages/tutorials/email-js/deploying.md","id":"deploying","url":"/tutorials/email-js/deploying.html"},"email-parameters":{"buttonTitle":"I have setup my email parameters!","description":"In this section, you'll learn how to enable WeDeploy Email on your application.","layout":"tutorial","parentId":"email-js","time":3,"title":"Setup email parameters","tutorialTitle":"Getting started with WeDeploy Email using Javascript","weight":5,"content":" Setup Email Parameters We have a local deployment of our email sample site but the Submit button is not working. We need to edit the parameters to make it active. Open tutorial-email-js/hosting/main.js in your text editor. Right bellow WeDeploy on line 6, paste this code: .url('http://email.test-email-js.wedeploy.me/emails') .auth('dummyMasterToken') .url is specifying the project and service that it would send the emails through. In your future project, put http://..wedeploy.io/emails here (notice that you must change the .me to .io for deployment). .auth is the authentication key. For demo purposes, we created a dummy local masterToken within the project.json file. For future deployment, you will need to find your project's master token on the settings tab inside your project's dashboard. Right bellow that, paste this code: .form('from', form.from.value) .form('to', form.to.value) .form('subject', form.subject.value) .form('message', form.subject.value) .post() form, to, subject, and message are all email parameter that allow you to choose what form inputs correlate to what email elements. .post() is the api request to send the email. Now go back to the homepage and try sending an email to yourself. ","srcFilePath":"src/pages/tutorials/email-js/email-parameters.md","id":"email-parameters","url":"/tutorials/email-js/email-parameters.html"},"getting-started":{"buttonTitle":"I'm ready to start!","description":"In this section, you'll learn how to enable WeDeploy Email on your application.","layout":"tutorial","parentId":"email-js","time":5,"title":"Getting Started","tutorialTitle":"Getting started with WeDeploy Email using Javascript","weight":1,"content":" Getting Started You are here because you just finished installing the Email service on your project. In this tutorial you will learn how to setup a test environment for your project using our boilerplate and how to deploy the Data service using Javascript. What to expect How to setup your machine as a local dev environment How to create the necessary files for your containers How to run your service locally How to push your service into deployment What you'll need Git (download for Linux, macOS, Windows) Docker (download for Linux, macOS, Windows) WeDeploy CLI For linux systems, open your Terminal and run: curl http://cdn.wedeploy.com/cli/latest/wedeploy.sh -sL | bash For Windows, you probably want the Windows amd64 installer For other systems, cehck the list of all builds available ","srcFilePath":"src/pages/tutorials/email-js/getting-started.md","id":"getting-started","url":"/tutorials/email-js/getting-started.html"},"running-locally":{"buttonTitle":"My local environment is running!","description":"In this section, you'll learn how to enable WeDeploy Email on your application.","layout":"tutorial","parentId":"email-js","time":5,"title":"Running locally","tutorialTitle":"Getting started with WeDeploy Email using Javascript","weight":4,"content":" Running locally WeDeploy provides a dev environment for you to run and test your app before pushing it to production. Lets get that running for this project! In your terminal, go to tutorial-email-js and run we dev. You can now go to http://tutorial-email-js.wedeploy.me in your browser and see the local deployment of your project. Any changes you make to your project folder now will automatically be deployed to this local server. ","srcFilePath":"src/pages/tutorials/email-js/running-locally.md","id":"running-locally","url":"/tutorials/email-js/running-locally.html"}},"description":"In this section, you'll learn how to enable WeDeploy Email on your application.","title":"Javascript Email Tutorial","tutorialTitle":"Getting started with WeDeploy Email using Javascript","url":"/tutorials/email-js/getting-started.html","hidden":true,"content":" ","srcFilePath":"src/pages/tutorials/email-js/index.soy","id":"email-js","location":"/tutorials/email-js","childIds":["getting-started","clone-sample","add-files","running-locally","email-parameters","deploying"]},"hosting":{"children":{"container-json":{"buttonTitle":"I added the container.json!","description":"In this section, you'll learn how to deploy an application using WeDeploy Hosting.","layout":"tutorial","parentId":"hosting","time":5,"title":"Adding the container.json","tutorialTitle":"Getting started with WeDeploy Hosting","weight":3,"content":" Adding the container.json Every WeDeploy container needs a container.json file to specify the id and type of service you are using. Let's create one for hosting. Go to the tutorial-hosting directory Create a file called container.json Open it in your text editor Paste the follow code { \"id\": \"hosting\", \"type\": \"wedeploy/hosting\" } id is the custom name designated for this service. If you named your service something other than \"hosting\", change the value of the id to the name of the hosting service you created on the dashboard. type tells WeDeploy what service to use. ","srcFilePath":"src/pages/tutorials/hosting/container-json.md","id":"container-json","url":"/tutorials/hosting/container-json.html"},"deploying":{"buttonTitle":"My project is live!","description":"In this section, you'll learn how to deploy an application using WeDeploy Hosting.","layout":"tutorial","parentId":"hosting","time":5,"title":"Deploying your service","tutorialTitle":"Getting started with WeDeploy Hosting","weight":6,"content":" Deploying your project Now its time to push your local files to your WeDeploy project. First, add a git remote. Within tutorial-hosting on your command line, run: git remote add wedeploy http://git.wedeploy.com/.git Then make a first commit git add . git commit -m \"Awesome change\" git push wedeploy master Go to the WeDeploy dashboard and select your project. On the right you should see the build log of your recent commit. Once you see \"Deploy was successful\" go to ..wedeploy.io. Voil√†! Your page is live! ","srcFilePath":"src/pages/tutorials/hosting/deploying.md","id":"deploying","url":"/tutorials/hosting/deploying.html"},"getting-started":{"buttonTitle":"I'm ready to start","description":"In this section, you'll learn how to deploy an application using WeDeploy Hosting.","layout":"tutorial","parentId":"hosting","time":5,"title":"Getting Started","tutorialTitle":"Getting started with WeDeploy Hosting","weight":1,"content":" Getting Started You are here because you just finished installing the host service on your project. In this tutorial you will learn how to setup a test environment for your project and how to deploy those files to the Hosting service. What to expect How to setup your machine as a local dev environment How to run and test your service locally How to push your service into deployment What you'll need Git (download for Linux, macOS, Windows) Docker (download for Linux, macOS, Windows) WeDeploy CLI For macOS and inux systems, open your Terminal and run: curl http://cdn.wedeploy.com/cli/latest/wedeploy.sh -sL | bash For Windows, you probably want the Windows amd64 installer For other systems, cehck the list of all builds available ","srcFilePath":"src/pages/tutorials/hosting/getting-started.md","id":"getting-started","url":"/tutorials/hosting/getting-started.html"},"running-locally":{"buttonTitle":"The local environment is running!","description":"In this section, you'll learn how to deploy an application using WeDeploy Hosting.","layout":"tutorial","parentId":"hosting","time":5,"title":"Running locally","tutorialTitle":"Getting started with WeDeploy Hosting","weight":4,"content":" Running locally WeDeploy provides a dev environment for you to run and test your apps before pushing them to production. Let's set that up! In your terminal, go to your project directory and run we dev. You can go to http://.tutorial-hosting.wedeploy.me in your browser and see the local deployment of the sample static site. Any changes you make to your project folder now will automatically be deployed to this local server. ","srcFilePath":"src/pages/tutorials/hosting/running-locally.md","id":"running-locally","url":"/tutorials/hosting/running-locally.html"},"sample-files":{"buttonTitle":"I have the sample files on my machine!","description":"In this section, you'll learn how to deploy an application using WeDeploy Hosting.","layout":"tutorial","parentId":"hosting","time":5,"title":"Clone the sample repo","tutorialTitle":"Getting started with WeDeploy Hosting","weight":2,"content":" Clone the sample repo To start, you will clone our sample files so you can get to know the deployment process. After the tutorial, you are free to add your own files to the folder or start from scratch with a new service. First, run this command in your terminal: git clone https://github.com/jonnilundy/tutorial-hosting.git You now have a folder called tutorial-hosting that contains almost all the files necessary to get your static site of the ground- besides one. ","srcFilePath":"src/pages/tutorials/hosting/sample-files.md","id":"sample-files","url":"/tutorials/hosting/sample-files.html"},"testing-locally":{"buttonTitle":"I changed 'It works!'' to 'You rock!'","description":"In this section, you'll learn how to deploy an application using WeDeploy Dashboard.","layout":"tutorial","parentId":"hosting","time":3,"title":"Testing locally","tutorialTitle":"Getting started with WeDeploy Hosting","weight":5,"content":" Testing locally Now that we have the local environment running, let's test the project by making a change to it. Open tutorial-hosting in your text editor. Go to index.html and change the text inside the ` element from It works! to You rock!`. Save the file, go back to your browser, and refresh the page. You should see the text change to \"You Rock! (because lets be honest, you do!). ","srcFilePath":"src/pages/tutorials/hosting/testing-locally.md","id":"testing-locally","url":"/tutorials/hosting/testing-locally.html"}},"description":"In this section, you'll learn how to deploy an application using WeDeploy Hosting.","title":"Hosting Tutorial","tutorialTitle":"Getting started with WeDeploy Hosting","url":"/tutorials/hosting/getting-started.html","hidden":true,"content":" ","srcFilePath":"src/pages/tutorials/hosting/index.soy","id":"hosting","location":"/tutorials/hosting","childIds":["getting-started","sample-files","container-json","running-locally","testing-locally","deploying"]}},"childIds":["hosting","auth-js","data-js","email-js"]}},"description":"Forget about infrastructure. Dedicate your time to what really matters: building great apps.","content":" WeDeploy‚Ñ¢ CLI Available Commands: create Creates a project or container; run Run the infrastructure for development locally; link Links the given project or service locally; $ we create | ","srcFilePath":"src/pages/index.soy","id":"pages","url":"/.","childIds":["blog","docs","chat","login","get-started","terms","tutorials"]}}